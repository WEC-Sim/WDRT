

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>WDRT.ESSC &mdash; WDRT 1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> WDRT
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Toolbox Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contact.html">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">WDRT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>WDRT.ESSC</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for WDRT.ESSC</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2016 Sandia Corporation and the National Renewable Energy</span>
<span class="c1"># Laboratory</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">The Extreme Sea State Contour (ESSC) module contains the tools necessary to </span>
<span class="sd">calculate environmental contours of extreme sea states for buoy data. </span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">optim</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">interp</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span> <span class="k">as</span> <span class="n">skPCA</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">bs4</span>
<span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">date</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
<span class="kn">from</span> <span class="nn">statsmodels</span> <span class="kn">import</span> <span class="n">robust</span>
<span class="kn">import</span> <span class="nn">urllib</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>


<div class="viewcode-block" id="EA"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA">[docs]</a><span class="k">class</span> <span class="nc">EA</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;The Environmental Assessment (EA) class points to functions for </span>
<span class="sd">    various contour methods (including getContours and getSamples) and allows </span>
<span class="sd">    the user to plot results (plotData), sample along the contour </span>
<span class="sd">    (getContourPoints), calculate the wave breaking steepness curve (steepness)</span>
<span class="sd">    and/or use the bootstrap method to calculate 95% confidence bounds about  </span>
<span class="sd">    the contours (bootStrap).&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">():</span>
        <span class="k">return</span>
<div class="viewcode-block" id="EA.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">():</span>
        <span class="sd">&#39;&#39;&#39;Points to the getContours function in whatever contouring method is used&#39;&#39;&#39;</span>
        <span class="k">return</span></div>
<div class="viewcode-block" id="EA.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">():</span>
        <span class="sd">&#39;&#39;&#39;Points to the getSamples function in whatever contouring method is</span>
<span class="sd">        used, currently only implemented for PCA contours. Implementation for </span>
<span class="sd">        additional contour methods planned for future release.&#39;&#39;&#39;</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="EA.saveContour"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.saveContour">[docs]</a>    <span class="k">def</span> <span class="nf">saveContour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Saves all available contour data obtained via the EA module to</span>
<span class="sd">        a .h5 file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fileName : string</span>
<span class="sd">            relevent path and filename where the .h5 file will be created and</span>
<span class="sd">            saved. If no filename, the h5 file will be named NDBC(buoyNum).h5</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fileName</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">fileName</span> <span class="o">=</span> <span class="s1">&#39;NDBC&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.h5&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">file_extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_extension</span><span class="p">:</span>
                <span class="n">fileName</span> <span class="o">=</span> <span class="n">fileName</span> <span class="o">+</span> <span class="s1">&#39;.h5&#39;</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span><span class="s1">&#39;method&#39;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">):</span>
                <span class="n">f</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
            
            <span class="k">if</span><span class="p">(</span><span class="s1">&#39;parameters&#39;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">):</span>
                <span class="n">gp</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gp</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;parameters&#39;</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_saveParams</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span>

            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="s1">&#39;ReturnContours&#39;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">):</span>                
                    <span class="n">grc</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;ReturnContours&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>                   
                    <span class="n">grc</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;ReturnContours&#39;</span><span class="p">)</span>
                
                <span class="k">if</span><span class="p">(</span><span class="s1">&#39;T_Return&#39;</span> <span class="ow">in</span> <span class="n">grc</span><span class="p">):</span>
                    <span class="n">f_T_Return</span> <span class="o">=</span> <span class="n">grc</span><span class="p">[</span><span class="s1">&#39;T_Return&#39;</span><span class="p">]</span>
                    <span class="n">f_T_Return</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_T_Return</span> <span class="o">=</span> <span class="n">grc</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;T_Return&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">)</span>                
                
                <span class="n">f_T_Return</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
                <span class="n">f_T_Return</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;contour, energy period&#39;</span>
                
                <span class="k">if</span><span class="p">(</span><span class="s1">&#39;Hs_Return&#39;</span> <span class="ow">in</span> <span class="n">grc</span><span class="p">):</span>
                    <span class="n">f_Hs_Return</span> <span class="o">=</span> <span class="n">grc</span><span class="p">[</span><span class="s1">&#39;Hs_Return&#39;</span><span class="p">]</span>
                    <span class="n">f_Hs_Return</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_Hs_Return</span> <span class="o">=</span> <span class="n">grc</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Hs_Return&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">)</span>
                
                <span class="n">f_Hs_Return</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
                <span class="n">f_Hs_Return</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;contours, significant wave height&#39;</span>

            <span class="c1"># Samples for full sea state long term analysis</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Hs_SampleFSS&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleFSS</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="s1">&#39;Samples_FullSeaState&#39;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">):</span>
                    <span class="n">gfss</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;Samples_FullSeaState&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>    
                    <span class="n">gfss</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;Samples_FullSeaState&#39;</span><span class="p">)</span>
                
                <span class="k">if</span><span class="p">(</span><span class="s1">&#39;Hs_SampleFSS&#39;</span> <span class="ow">in</span> <span class="n">gfss</span><span class="p">):</span>
                    <span class="n">f_Hs_SampleFSS</span> <span class="o">=</span> <span class="n">gfss</span><span class="p">[</span><span class="s1">&#39;Hs_SampleFSS&#39;</span><span class="p">]</span>
                    <span class="n">f_Hs_SampleFSS</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleFSS</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_Hs_SampleFSS</span> <span class="o">=</span> <span class="n">gfss</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Hs_SampleFSS&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleFSS</span><span class="p">)</span>
                
                <span class="n">f_Hs_SampleFSS</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
                <span class="n">f_Hs_SampleFSS</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;full sea state significant wave height samples&#39;</span>
                
                <span class="k">if</span><span class="p">(</span><span class="s1">&#39;T_SampleFSS&#39;</span> <span class="ow">in</span> <span class="n">gfss</span><span class="p">):</span>
                    <span class="n">f_T_SampleFSS</span> <span class="o">=</span> <span class="n">gfss</span><span class="p">[</span><span class="s1">&#39;T_SampleFSS&#39;</span><span class="p">]</span>
                    <span class="n">f_T_SampleFSS</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_SampleFSS</span>
                <span class="k">else</span><span class="p">:</span>   
                    <span class="n">f_T_SampleFSS</span> <span class="o">=</span> <span class="n">gfss</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;T_SampleFSS&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">T_SampleFSS</span><span class="p">)</span>                
                
                <span class="n">f_T_SampleFSS</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
                <span class="n">f_T_SampleFSS</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;full sea state energy period samples&#39;</span>                
                
                <span class="k">if</span><span class="p">(</span><span class="s1">&#39;Weight_SampleFSS&#39;</span> <span class="ow">in</span> <span class="n">gfss</span><span class="p">):</span>
                    <span class="n">f_Weight_SampleFSS</span> <span class="o">=</span> <span class="n">gfss</span><span class="p">[</span><span class="s1">&#39;Weight_SampleFSS&#39;</span><span class="p">]</span>
                    <span class="n">f_Weight_SampleFSS</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Weight_SampleFSS</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_Weight_SampleFSS</span> <span class="o">=</span> <span class="n">gfss</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Weight_SampleFSS&#39;</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Weight_SampleFSS</span><span class="p">)</span>
                
                <span class="n">f_Weight_SampleFSS</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;full sea state relative weighting samples&#39;</span>

            <span class="c1"># Samples for contour approach long term analysis</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Hs_SampleCA&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleCA</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span><span class="p">(</span><span class="s1">&#39;Samples_ContourApproach&#39;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">):</span>
                    <span class="n">gca</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;Samples_ContourApproach&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gca</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;Samples_ContourApproach&#39;</span><span class="p">)</span>
                
                <span class="k">if</span><span class="p">(</span><span class="s1">&#39;Hs_SampleCA&#39;</span> <span class="ow">in</span> <span class="n">gca</span><span class="p">):</span>
                    <span class="n">f_Hs_sampleCA</span> <span class="o">=</span> <span class="n">gca</span><span class="p">[</span><span class="s1">&#39;Hs_SampleCA&#39;</span><span class="p">]</span>
                    <span class="n">f_Hs_sampleCA</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleCA</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_Hs_sampleCA</span> <span class="o">=</span> <span class="n">gca</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Hs_SampleCA&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleCA</span><span class="p">)</span>
                
                <span class="n">f_Hs_sampleCA</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
                <span class="n">f_Hs_sampleCA</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;contour approach significant wave height samples&#39;</span>
                
                <span class="k">if</span><span class="p">(</span><span class="s1">&#39;T_SampleCA&#39;</span> <span class="ow">in</span> <span class="n">gca</span><span class="p">):</span>
                    <span class="n">f_T_sampleCA</span> <span class="o">=</span> <span class="n">gca</span><span class="p">[</span><span class="s1">&#39;T_SampleCA&#39;</span><span class="p">]</span>
                    <span class="n">f_T_sampleCA</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_SampleCA</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_T_sampleCA</span> <span class="o">=</span> <span class="n">gca</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;T_SampleCA&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">T_SampleCA</span><span class="p">)</span>
                
                <span class="n">f_T_sampleCA</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
                <span class="n">f_T_sampleCA</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;contour approach energy period samples&#39;</span></div>

<div class="viewcode-block" id="EA.plotData"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.plotData">[docs]</a>    <span class="k">def</span> <span class="nf">plotData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display a plot of the 100-year return contour, full sea state samples</span>
<span class="sd">        and contour samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">,</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;NDBC data&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;100 year contour&#39;</span><span class="p">)</span>
        <span class="c1">#plt.plot(self.T_SampleFSS, self.Hs_SampleFSS, &#39;ro&#39;, label=&#39;full sea state samples&#39;)</span>
        <span class="c1">#plt.plot(self.T_SampleCA, self.Hs_SampleCA, &#39;y^&#39;, label=&#39;contour approach samples&#39;)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;small&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Energy period, $T_e$ [s]&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Sig. wave height, $H_s$ [m]&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="EA.getContourPoints"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.getContourPoints">[docs]</a>    <span class="k">def</span> <span class="nf">getContourPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T_Sample</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get Hs points along a specified environmental contour using </span>
<span class="sd">        user-defined T values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            T_Sample : nparray</span>
<span class="sd">                points for sampling along return contour</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            Hs_SampleCA : nparray</span>
<span class="sd">                points sampled along return contour</span>
<span class="sd">        </span>
<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">            To calculate Hs values along the contour at specific </span>
<span class="sd">            user-defined T values:</span>
<span class="sd">            </span>
<span class="sd">                import WDRT.ESSC as ESSC</span>
<span class="sd">                import numpy as np</span>
<span class="sd">                </span>
<span class="sd">                # Pull spectral data from NDBC website</span>
<span class="sd">                buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">                buoy46022.fetchFromWeb()</span>
<span class="sd">                </span>
<span class="sd">                # Create PCA EA object for buoy</span>
<span class="sd">                pca46022 = ESSC.PCA(buoy46022)</span>
<span class="sd">                </span>
<span class="sd">                # Declare required parameters</span>
<span class="sd">                Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">                Time_r = 100  # Return periods (yrs) of interest</span>
<span class="sd">                nb_steps = 1000  # Enter discretization of the circle in the normal space (optional)</span>
<span class="sd">                </span>
<span class="sd">                # Generate contour</span>
<span class="sd">                Hs_Return, T_Return = pca46022.getContours(Time_SS, Time_r,nb_steps)</span>
<span class="sd">                </span>
<span class="sd">                # Use getContourPoints to find specific points along the contour</span>
<span class="sd">                T_sampleCA = np.arange(12, 26, 2)</span>
<span class="sd">                Hs_sampleCA = pca46022.getContourPoints(T_sampleCA)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#finds minimum and maximum energy period values</span>
        <span class="n">amin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">)</span>
        <span class="n">amax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">)</span>
        <span class="c1">#finds points along the contour</span>
        <span class="n">w1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">[</span><span class="n">amin</span><span class="p">:</span><span class="n">amax</span><span class="p">]</span>
        <span class="n">w2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">[</span><span class="n">amax</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">[:</span><span class="n">amin</span><span class="p">]))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">w1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">w2</span><span class="p">)):</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">[</span><span class="n">amin</span><span class="p">:</span><span class="n">amax</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">[</span><span class="n">amin</span><span class="p">:</span><span class="n">amax</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">[</span><span class="n">amax</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">[:</span><span class="n">amin</span><span class="p">]))</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">[</span><span class="n">amax</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">[:</span><span class="n">amin</span><span class="p">]))</span>
        <span class="c1">#sorts data based on the max and min energy period values</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">ms</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">ms</span><span class="p">]</span>
        <span class="c1">#interpolates the sorted data</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="c1">#finds the wave height based on the user specified energy period values</span>
        <span class="n">Hs_SampleCA</span> <span class="o">=</span> <span class="n">si</span><span class="p">(</span><span class="n">T_Sample</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">T_SampleCA</span> <span class="o">=</span> <span class="n">T_Sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleCA</span> <span class="o">=</span> <span class="n">Hs_SampleCA</span>
        <span class="k">return</span> <span class="n">Hs_SampleCA</span></div>

<div class="viewcode-block" id="EA.steepness"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.steepness">[docs]</a>    <span class="k">def</span> <span class="nf">steepness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SteepMax</span><span class="p">,</span> <span class="n">T_vals</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;This function calculates a steepness curve to be plotted on an H vs. T</span>
<span class="sd">        diagram.  First, the function calculates the wavelength based on the</span>
<span class="sd">        depth and T. The T vector can be the input data vector, or will be</span>
<span class="sd">        created below to cover the span of possible T values.</span>
<span class="sd">        The function solves the dispersion relation for water waves</span>
<span class="sd">        using the Newton-Raphson method. All outputs are solved for exactly</span>
<span class="sd">        using: :math:`hw^2/g = kh*tanh(khG)` </span>
<span class="sd">        </span>
<span class="sd">        Approximations that could be used in place of this code for deep</span>
<span class="sd">        and shallow water, as appropriate:</span>
<span class="sd">            </span>
<span class="sd">        deep water: :math:`h/\lambda \geq 1/2, tanh(kh) \sim 1, \lambda = (gT^2)/(2\pi)`</span>
<span class="sd">        </span>
<span class="sd">        shallow water: :math:`h/\lambda \leq 1/20, tanh(kh) \sim kh, \lambda = \sqrt{T(gh)}`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        SteepMax: float</span>
<span class="sd">            Wave breaking steepness estimate (e.g., 0.07).</span>
<span class="sd">        T_vals :np.array</span>
<span class="sd">            Array of T values [sec] at which to calculate the breaking height.</span>
<span class="sd">        depth: float</span>
<span class="sd">            Depth at site</span>
<span class="sd">            Note: if not inputted, the depth will tried to be grabbed from the respective</span>
<span class="sd">            buoy type&#39;s website.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SteepH: np.array</span>
<span class="sd">            H values [m] that correspond to the T_mesh values creating the</span>
<span class="sd">            steepness curve.</span>
<span class="sd">        T_steep: np.array</span>
<span class="sd">            T values [sec] over which the steepness curve is defined.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        To find limit the steepness of waves on a contour by breaking:</span>
<span class="sd">            </span>
<span class="sd">            import numpy as np</span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            </span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            </span>
<span class="sd">            # Create PCA EA object for buoy</span>
<span class="sd">            pca46022 = ESSC.PCA(buoy46022)</span>
<span class="sd">            </span>
<span class="sd">            T_vals = np.arange(0.1, np.amax(buoy46022.T), 0.1)</span>
<span class="sd">            # Enter estimate of breaking steepness</span>
<span class="sd">            SteepMax = 0.07  # Reference DNV-RP-C205</span>
<span class="sd">            </span>
<span class="sd">            # Declare required parameters</span>
<span class="sd">            depth = 391.4  # Depth at measurement point (m)</span>
<span class="sd">            </span>
<span class="sd">            SteepH = pca46022.steepness(depth,SteepMax,T_vals)</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Calculate the wavelength at a given depth at each value of T</span>

        <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fetchDepth</span><span class="p">()</span>
        <span class="n">lambdaT</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>  <span class="c1"># [m/s^2]</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="n">T_vals</span><span class="p">)</span>
        <span class="n">lambdaT</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">T_vals</span><span class="p">)):</span>
            <span class="c1"># Initialize kh using Eckart 1952 (mentioned in Holthuijsen pg. 124)</span>
            <span class="n">kh</span> <span class="o">=</span> <span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">depth</span> <span class="o">/</span> \
                <span class="p">(</span><span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">depth</span> <span class="o">/</span> <span class="n">g</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span>
            <span class="c1"># Find solution using the Newton-Raphson Method</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
                <span class="n">kh0</span> <span class="o">=</span> <span class="n">kh</span>
                <span class="n">f0</span> <span class="o">=</span> <span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">depth</span> <span class="o">/</span> <span class="n">g</span> <span class="o">-</span> <span class="n">kh0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">kh0</span><span class="p">)</span>
                <span class="n">df0</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">kh</span><span class="p">)</span> <span class="o">-</span> <span class="n">kh</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">kh</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">kh</span> <span class="o">=</span> <span class="o">-</span><span class="n">f0</span> <span class="o">/</span> <span class="n">df0</span> <span class="o">+</span> <span class="n">kh0</span>
                <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">depth</span> <span class="o">/</span> <span class="n">g</span> <span class="o">-</span> <span class="n">kh</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">kh</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f0</span> <span class="o">-</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">):</span>
                    <span class="k">break</span>

            <span class="n">lambdaT</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">kh</span> <span class="o">/</span> <span class="n">depth</span><span class="p">))</span>
            <span class="k">del</span> <span class="n">kh</span><span class="p">,</span> <span class="n">kh0</span>

        <span class="n">lambdaT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lambdaT</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">SteepH</span> <span class="o">=</span> <span class="n">lambdaT</span> <span class="o">*</span> <span class="n">SteepMax</span>
        <span class="k">return</span> <span class="n">SteepH</span></div>
    
    <span class="k">def</span> <span class="nf">__fetchDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Obtains the depth from the website for a buoy (either NDBC or CDIP)&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">buoyType</span> <span class="o">==</span> <span class="s2">&quot;NDBC&quot;</span><span class="p">:</span>
            <span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://www.ndbc.noaa.gov/station_page.php?station=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">46022</span><span class="p">)</span>
            <span class="n">ndbcURL</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="n">ndbcURL</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>
            <span class="n">ndbcHTML</span> <span class="o">=</span> <span class="n">bs4</span><span class="o">.</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">ndbcURL</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="s2">&quot;lxml&quot;</span><span class="p">)</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">ndbcHTML</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">&quot;Water depth:&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">nextSibling</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">buoyType</span> <span class="o">==</span> <span class="s2">&quot;CDIP&quot;</span><span class="p">:</span>
            <span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;http://cdip.ucsd.edu/cgi-bin/wnc_metadata?ARCHIVE/</span><span class="si">%s</span><span class="s2">p1/</span><span class="si">%s</span><span class="s2">p1_historic&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">)</span>
            <span class="n">cdipURL</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="n">cdipURL</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>
            <span class="n">cdipHTML</span> <span class="o">=</span> <span class="n">bs4</span><span class="o">.</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">cdipURL</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="s2">&quot;lxml&quot;</span><span class="p">)</span>
            <span class="c1">#Parse the table for the depth value</span>
            <span class="n">depthString</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">cdipHTML</span><span class="o">.</span><span class="n">findChildren</span><span class="p">(</span><span class="s2">&quot;td&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;class&quot;</span> <span class="p">:</span> <span class="s2">&quot;plus&quot;</span><span class="p">})[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">depthString</span> <span class="o">=</span> <span class="n">depthString</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&lt;br/&gt;&quot;</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[-+]?\d*\.\d+|\d+&quot;</span><span class="p">,</span> <span class="n">depthString</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>



<div class="viewcode-block" id="EA.bootStrap"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.bootStrap">[docs]</a>    <span class="k">def</span> <span class="nf">bootStrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boot_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">plotResults</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get 95% confidence bounds about a contour using the bootstrap</span>
<span class="sd">        method. Warning - this function is time consuming. Computation </span>
<span class="sd">        time depends on selected boot_size.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            boot_size: int (optional)</span>
<span class="sd">                Number of bootstrap samples that will be used to calculate 95%</span>
<span class="sd">                confidence interval. Should be large enough to calculate stable</span>
<span class="sd">                statistics. If left blank will be set to 1000.</span>
<span class="sd">            plotResults: boolean (optional)</span>
<span class="sd">                Option for showing plot of bootstrap confidence bounds. If left</span>
<span class="sd">                blank will be set to True and plot will be shown.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            contourmean_Hs : nparray</span>
<span class="sd">                Hs values for mean contour calculated as the average over all</span>
<span class="sd">                bootstrap contours.</span>
<span class="sd">            contourmean_T : nparray</span>
<span class="sd">                T values for mean contour calculated as the average over all</span>
<span class="sd">                bootstrap contours.</span>
<span class="sd">        </span>
<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To generate 95% boostrap contours for a given contour method:</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            </span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            </span>
<span class="sd">            # Create PCA EA object for buoy</span>
<span class="sd">            pca46022 = ESSC.PCA(buoy46022)</span>
<span class="sd">            </span>
<span class="sd">            # Declare required parameters</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = 100  # Return periods (yrs) of interest</span>
<span class="sd">            nb_steps = 1000  # Enter discretization of the circle in the normal space (optional)</span>
<span class="sd">            </span>
<span class="sd">            # Contour generation</span>
<span class="sd">            Hs_Return, T_Return = pca46022.getContours(Time_SS, Time_r,nb_steps)</span>
<span class="sd">            </span>
<span class="sd">            # Calculate boostrap confidence interval</span>
<span class="sd">            contourmean_Hs, contourmean_T = pca46022.bootStrap(boot_size=10)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#preallocates arrays</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span>
        <span class="n">Hs_Return_Boot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span><span class="p">,</span><span class="n">boot_size</span><span class="p">])</span>
        <span class="n">T_Return_Boot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span><span class="p">,</span><span class="n">boot_size</span><span class="p">])</span>
        <span class="n">buoycopy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="p">);</span>
        <span class="c1">#creates copies of the data based on how it was modeled.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">boot_size</span><span class="p">):</span>
            <span class="n">boot_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
            <span class="n">buoycopy</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">boot_inds</span><span class="p">])</span>
            <span class="n">buoycopy</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">boot_inds</span><span class="p">])</span>
            <span class="n">essccopy</span><span class="o">=</span><span class="kc">None</span>            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Principle component analysis&quot;</span><span class="p">:</span>
                <span class="n">essccopy</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">buoycopy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_bin</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Gaussian Copula&quot;</span><span class="p">:</span>
                <span class="n">essccopy</span> <span class="o">=</span> <span class="n">GaussianCopula</span><span class="p">(</span><span class="n">buoycopy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Rosenblatt&quot;</span><span class="p">:</span>
                <span class="n">essccopy</span> <span class="o">=</span> <span class="n">Rosenblatt</span><span class="p">(</span><span class="n">buoycopy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Clayton Copula&quot;</span><span class="p">:</span>
                <span class="n">essccopy</span> <span class="o">=</span> <span class="n">ClaytonCopula</span><span class="p">(</span><span class="n">buoycopy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Gumbel Copula&quot;</span><span class="p">:</span>
                <span class="n">essccopy</span> <span class="o">=</span> <span class="n">GumbelCopula</span><span class="p">(</span><span class="n">buoycopy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Non-parametric Gaussian Copula&quot;</span><span class="p">:</span>
                <span class="n">essccopy</span> <span class="o">=</span> <span class="n">NonParaGaussianCopula</span><span class="p">(</span><span class="n">buoycopy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_Hs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Non-parametric Clayton Copula&quot;</span><span class="p">:</span>
                <span class="n">essccopy</span> <span class="o">=</span> <span class="n">NonParaClaytonCopula</span><span class="p">(</span><span class="n">buoycopy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_Hs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Non-parametric Gumbel Copula&quot;</span><span class="p">:</span>
                <span class="n">essccopy</span> <span class="o">=</span> <span class="n">NonParaGumbelCopula</span><span class="p">(</span><span class="n">buoycopy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_Hs</span><span class="p">)</span>
            <span class="n">Hs_Return_Boot</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span><span class="n">T_Return_Boot</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">essccopy</span><span class="o">.</span><span class="n">getContours</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span><span class="p">)</span>

        <span class="c1">#finds 95% CI values for wave height and energy</span>
        <span class="n">contour97_5_Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">Hs_Return_Boot</span><span class="p">,</span><span class="mf">97.5</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">contour2_5_Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">Hs_Return_Boot</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">contourmean_Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hs_Return_Boot</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">contour97_5_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">T_Return_Boot</span><span class="p">,</span><span class="mf">97.5</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">contour2_5_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">T_Return_Boot</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">contourmean_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">T_Return_Boot</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">contourMean_Hs</span> <span class="o">=</span> <span class="n">contourmean_Hs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contourMean_T</span> <span class="o">=</span> <span class="n">contourmean_T</span>
        <span class="c1">#plotting function</span>
        <span class="k">def</span> <span class="nf">plotResults</span><span class="p">():</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">,</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;NDBC data&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;100 year contour&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">contour97_5_T</span><span class="p">,</span> <span class="n">contour97_5_Hs</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95% bootstrap confidence interval&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">contour2_5_T</span><span class="p">,</span> <span class="n">contour2_5_Hs</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">contourmean_T</span><span class="p">,</span> <span class="n">contourmean_Hs</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Mean bootstrap contour&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;small&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Energy period, $T_e$ [s]&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Sig. wave height, $H_s$ [m]&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">plotResults</span><span class="p">:</span>
            <span class="n">plotResults</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">contourmean_Hs</span><span class="p">,</span> <span class="n">contourmean_T</span></div>

<div class="viewcode-block" id="EA.outsidePoints"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.outsidePoints">[docs]</a>    <span class="k">def</span> <span class="nf">outsidePoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        
        <span class="sd">&#39;&#39;&#39;Determines which buoy observations are outside of a given contour.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            None</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            outsideHs : nparray</span>
<span class="sd">                The Hs values of the observations that are outside of the contour</span>
<span class="sd">        </span>
<span class="sd">            outsideT : nparray</span>
<span class="sd">                The T values of the observations that are outside of the contour</span>
<span class="sd">        </span>
<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">            To get correseponding T and Hs arrays of observations that are outside</span>
<span class="sd">            of a given contour:</span>
<span class="sd">                </span>
<span class="sd">                import WDRT.ESSC as ESSC</span>
<span class="sd">                import numpy as np</span>
<span class="sd">                </span>
<span class="sd">                # Pull spectral data from NDBC website</span>
<span class="sd">                buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">                buoy46022.fetchFromWeb()</span>
<span class="sd">                </span>
<span class="sd">                # Create PCA EA object for buoy</span>
<span class="sd">                rosen46022 = ESSC.Rosenblatt(buoy46022)</span>
<span class="sd">                </span>
<span class="sd">                # Declare required parameters</span>
<span class="sd">                Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">                Time_r = 100  # Return periods (yrs) of interest</span>
<span class="sd">                </span>
<span class="sd">                # Generate contour</span>
<span class="sd">                Hs_Return, T_Return = rosen46022.getContours(Time_SS, Time_r)</span>
<span class="sd">                </span>
<span class="sd">                # Return the outside point Hs/T combinations</span>
<span class="sd">                outsideT, outsideHs = rosen46022.outsidePoints()</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#checks if the contour type is a KDE contour - if so, finds the outside points for the KDE contour.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span> 
            <span class="n">contains_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span><span class="n">hs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">):</span>        
                <span class="n">path_contour</span> <span class="o">=</span> <span class="p">[]</span>        
                <span class="n">path_contour</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">t</span><span class="p">,</span><span class="n">hs</span><span class="p">)))</span>
                <span class="n">contains_test</span> <span class="o">=</span> <span class="n">contains_test</span><span class="o">+</span><span class="n">path_contour</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)))</span>
            <span class="n">out_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">contains_test</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># For non-KDE methods (copulas, etc.)</span>
            <span class="n">path_contour</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">)))</span>
            <span class="n">contains_test</span> <span class="o">=</span> <span class="n">path_contour</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)))</span>
            <span class="n">out_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">contains_test</span><span class="p">)</span>
        <span class="n">outsideHs</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">out_inds</span><span class="p">]</span>
        <span class="n">outsideT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">out_inds</span><span class="p">]</span>
        
        <span class="k">return</span><span class="p">(</span><span class="n">outsideT</span><span class="p">,</span> <span class="n">outsideHs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="EA.contourIntegrator"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.contourIntegrator">[docs]</a>    <span class="k">def</span> <span class="nf">contourIntegrator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>    
             
        <span class="sd">&#39;&#39;&#39;Calculates the area of the contour over the two-dimensional input</span>
<span class="sd">        space of interest. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            None</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            area : float</span>
<span class="sd">                The area of the contour in TxHs units. </span>
<span class="sd">        </span>
<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        To obtain the area of the contour:</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            </span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            </span>
<span class="sd">            # Create PCA EA object for buoy</span>
<span class="sd">            rosen46022 = ESSC.Rosenblatt(buoy46022)</span>
<span class="sd">            </span>
<span class="sd">            # Declare required parameters</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = 100  # Return periods (yrs) of interest</span>
<span class="sd">            </span>
<span class="sd">            # Generate contour</span>
<span class="sd">            Hs_Return, T_Return = rosen46022.getContours(Time_SS, Time_r)</span>
<span class="sd">            </span>
<span class="sd">            # Return the area of the contour</span>
<span class="sd">            rosenArea = rosen46022.contourIntegrator()</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>        
        
        <span class="n">contourTs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span>
        <span class="n">contourHs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span>
    
        <span class="n">area</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">contourTs</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">contourHs</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">contourHs</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">contourTs</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span> 
    
        <span class="k">return</span> <span class="n">area</span></div>
    
<div class="viewcode-block" id="EA.dataContour"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.dataContour">[docs]</a>    <span class="k">def</span> <span class="nf">dataContour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tStepSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hsStepSize</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="p">):</span>
    
        <span class="sd">&#39;&#39;&#39;Creates a contour around the ordered pairs of buoy observations. How tightly</span>
<span class="sd">           the contour fits around the data will be determined by step size parameters.</span>
<span class="sd">           Please note that this function currently is in beta; it needs further work to be</span>
<span class="sd">           optimized for use.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            tStepSize : float</span>
<span class="sd">                Determines how far to search for the next point in the T direction. </span>
<span class="sd">                Smaller values will produce contours that follow the data more closely.</span>
<span class="sd">    </span>
<span class="sd">            hsStepSize : float</span>
<span class="sd">                Determines how far to search for the next point in the Hs direction. </span>
<span class="sd">                Smaller values will produce contours that follow the data more closely.</span>
<span class="sd">                </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            dataBoundryHs : nparray</span>
<span class="sd">                The Hs values of the boundry observations</span>
<span class="sd">        </span>
<span class="sd">            dataBoundryT : nparray</span>
<span class="sd">                The Hs values of the boundry observations</span>
<span class="sd">        </span>
<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        To get the corresponding data contour:</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            </span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            </span>
<span class="sd">            # Create PCA EA object for buoy</span>
<span class="sd">            rosen46022 = ESSC.Rosenblatt(buoy46022)</span>
<span class="sd">            </span>
<span class="sd">            # Calculate the data contour</span>
<span class="sd">            dataHs, dataT = rosen46022.dataContour(tStepSize = 1, hsStepSize = .5)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>    
    
        
        
        <span class="n">maxHs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span>
        <span class="n">minHs</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span>
        
        <span class="n">sortedHsBuoy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="p">)</span>
        <span class="n">sortedTBuoy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="p">)</span>
        
        <span class="n">sortedTIndex</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="n">sortedHsIndex</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        
        <span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">sortedHsIndex</span><span class="p">]</span>
        <span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">sortedHsIndex</span><span class="p">]</span>
        <span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">sortedTIndex</span><span class="p">]</span>
        <span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">sortedTIndex</span><span class="p">]</span>
        
        <span class="n">hsBin1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hsBin2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hsBin3</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hsBin4</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tBin1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tBin2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tBin3</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tBin4</span> <span class="o">=</span> <span class="p">[]</span>
    
        
        <span class="n">startingPoint</span> <span class="o">=</span> <span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">hsBin4</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">tBin4</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">tempNextBinTs</span> <span class="o">=</span> <span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">T</span> <span class="o">&lt;</span> <span class="n">startingPoint</span> <span class="o">+</span> <span class="n">tStepSize</span><span class="p">]</span>    
            <span class="n">tempNextBinHs</span> <span class="o">=</span> <span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">T</span> <span class="o">&lt;</span> <span class="n">startingPoint</span> <span class="o">+</span> <span class="n">tStepSize</span><span class="p">]</span>
            <span class="n">nextBinTs</span> <span class="o">=</span> <span class="n">tempNextBinTs</span><span class="p">[</span><span class="n">tempNextBinTs</span> <span class="o">&gt;</span> <span class="n">startingPoint</span><span class="p">]</span>
            <span class="n">nextBinHs</span> <span class="o">=</span> <span class="n">tempNextBinHs</span><span class="p">[</span><span class="n">tempNextBinTs</span> <span class="o">&gt;</span> <span class="n">startingPoint</span><span class="p">]</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nextHs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nextBinHs</span><span class="p">)</span>
                <span class="n">nextT</span> <span class="o">=</span> <span class="n">nextBinTs</span><span class="p">[</span><span class="n">nextBinHs</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
                
                <span class="n">hsBin4</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nextHs</span><span class="p">)</span>
                <span class="n">tBin4</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nextT</span><span class="p">)</span>
            
                <span class="n">startingPoint</span> <span class="o">=</span> <span class="n">nextT</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">startingPoint</span> <span class="o">+=</span> <span class="n">tStepSize</span>
                <span class="k">break</span>
     
            <span class="k">if</span> <span class="n">nextHs</span> <span class="o">==</span> <span class="n">maxHs</span><span class="p">:</span>
                <span class="k">break</span>
        
        <span class="n">startingPoint</span> <span class="o">=</span> <span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">hsBin1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">tBin1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">tempNextBinTs</span> <span class="o">=</span> <span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">T</span> <span class="o">&lt;</span> <span class="n">startingPoint</span> <span class="o">+</span> <span class="n">tStepSize</span><span class="p">]</span>    
            <span class="n">tempNextBinHs</span> <span class="o">=</span> <span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">sortedTBuoy</span><span class="o">.</span><span class="n">T</span> <span class="o">&lt;</span> <span class="n">startingPoint</span> <span class="o">+</span> <span class="n">tStepSize</span><span class="p">]</span>
            <span class="n">nextBinTs</span> <span class="o">=</span> <span class="n">tempNextBinTs</span><span class="p">[</span><span class="n">tempNextBinTs</span> <span class="o">&gt;</span> <span class="n">startingPoint</span><span class="p">]</span>
            <span class="n">nextBinHs</span> <span class="o">=</span> <span class="n">tempNextBinHs</span><span class="p">[</span><span class="n">tempNextBinTs</span> <span class="o">&gt;</span> <span class="n">startingPoint</span><span class="p">]</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nextHs</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nextBinHs</span><span class="p">)</span>
                <span class="n">nextT</span> <span class="o">=</span> <span class="n">nextBinTs</span><span class="p">[</span><span class="n">nextBinHs</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
                
                <span class="n">hsBin1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nextHs</span><span class="p">)</span>
                <span class="n">tBin1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nextT</span><span class="p">)</span>
            
                <span class="n">startingPoint</span> <span class="o">=</span> <span class="n">nextT</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">startingPoint</span> <span class="o">+=</span> <span class="n">tStepSize</span>
                <span class="k">break</span>
            
            
            <span class="k">if</span> <span class="n">nextHs</span> <span class="o">==</span> <span class="n">minHs</span><span class="p">:</span>
                <span class="k">break</span>
        
        
        <span class="n">startingPoint</span> <span class="o">=</span> <span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
        <span class="n">hsBin3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>
        <span class="n">tBin3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">tempNextBinTs</span> <span class="o">=</span> <span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">Hs</span> <span class="o">&lt;</span> <span class="n">startingPoint</span> <span class="o">+</span> <span class="n">hsStepSize</span><span class="p">]</span>    
            <span class="n">tempNextBinHs</span> <span class="o">=</span> <span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">Hs</span> <span class="o">&lt;</span> <span class="n">startingPoint</span> <span class="o">+</span> <span class="n">hsStepSize</span><span class="p">]</span>
            <span class="n">nextBinTs</span> <span class="o">=</span> <span class="n">tempNextBinTs</span><span class="p">[</span><span class="n">tempNextBinHs</span> <span class="o">&gt;</span> <span class="n">startingPoint</span><span class="p">]</span>
            <span class="n">nextBinHs</span> <span class="o">=</span> <span class="n">tempNextBinHs</span><span class="p">[</span><span class="n">tempNextBinHs</span> <span class="o">&gt;</span> <span class="n">startingPoint</span><span class="p">]</span>
        
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nextT</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nextBinTs</span><span class="p">)</span>
                <span class="n">nextHs</span> <span class="o">=</span> <span class="n">nextBinHs</span><span class="p">[</span><span class="n">nextBinTs</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
                
                <span class="k">if</span> <span class="n">nextHs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hsBin4</span> <span class="ow">and</span> <span class="n">nextHs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hsBin1</span><span class="p">:</span>
                
                    <span class="n">hsBin3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nextHs</span><span class="p">)</span>
                    <span class="n">tBin3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nextT</span><span class="p">)</span>
        
                <span class="n">startingPoint</span> <span class="o">=</span> <span class="n">nextHs</span>
            
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">startingPoint</span> <span class="o">+=</span> <span class="n">hsStepSize</span>
                <span class="k">break</span>
    
            <span class="k">if</span> <span class="n">nextHs</span> <span class="o">==</span> <span class="n">maxHs</span><span class="p">:</span>
                <span class="k">break</span>
     
        
        <span class="n">startingPoint</span> <span class="o">=</span> <span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">tempNextBinTs</span> <span class="o">=</span> <span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">Hs</span> <span class="o">&gt;</span> <span class="n">startingPoint</span> <span class="o">-</span> <span class="n">hsStepSize</span><span class="p">]</span>    
            <span class="n">tempNextBinHs</span> <span class="o">=</span> <span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">sortedHsBuoy</span><span class="o">.</span><span class="n">Hs</span> <span class="o">&gt;</span> <span class="n">startingPoint</span> <span class="o">-</span> <span class="n">hsStepSize</span><span class="p">]</span>
            <span class="n">nextBinTs</span> <span class="o">=</span> <span class="n">tempNextBinTs</span><span class="p">[</span><span class="n">tempNextBinHs</span> <span class="o">&lt;</span> <span class="n">startingPoint</span><span class="p">]</span>
            <span class="n">nextBinHs</span> <span class="o">=</span> <span class="n">tempNextBinHs</span><span class="p">[</span><span class="n">tempNextBinHs</span> <span class="o">&lt;</span> <span class="n">startingPoint</span><span class="p">]</span>
        
            <span class="k">try</span><span class="p">:</span>    
                <span class="n">nextT</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nextBinTs</span><span class="p">)</span>
                <span class="n">nextHs</span> <span class="o">=</span> <span class="n">nextBinHs</span><span class="p">[</span><span class="n">nextBinTs</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
            
                <span class="k">if</span> <span class="n">nextHs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hsBin1</span> <span class="ow">and</span> <span class="n">nextHs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hsBin4</span><span class="p">:</span>
            
                    <span class="n">hsBin2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nextHs</span><span class="p">)</span>
                    <span class="n">tBin2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nextT</span><span class="p">)</span>
        
                <span class="n">startingPoint</span> <span class="o">=</span> <span class="n">nextHs</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">startingPoint</span> <span class="o">=</span> <span class="n">startingPoint</span> <span class="o">-</span> <span class="n">hsStepSize</span>
                <span class="k">break</span>
    
            
            <span class="k">if</span> <span class="n">nextHs</span> <span class="o">==</span> <span class="n">minHs</span><span class="p">:</span>
                <span class="k">break</span>
        
        <span class="n">hsBin2</span> <span class="o">=</span> <span class="n">hsBin2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Reverses the order of the array</span>
        <span class="n">tBin2</span> <span class="o">=</span> <span class="n">tBin2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">hsBin4</span> <span class="o">=</span> <span class="n">hsBin4</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Reverses the order of the array</span>
        <span class="n">tBin4</span> <span class="o">=</span> <span class="n">tBin4</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">dataBoundryHs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">hsBin1</span><span class="p">,</span><span class="n">hsBin2</span><span class="p">,</span><span class="n">hsBin3</span><span class="p">,</span><span class="n">hsBin4</span><span class="p">),</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">dataBoundryT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tBin1</span><span class="p">,</span><span class="n">tBin2</span><span class="p">,</span><span class="n">tBin3</span><span class="p">,</span><span class="n">tBin4</span><span class="p">),</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">dataBoundryHs</span> <span class="o">=</span> <span class="n">dataBoundryHs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dataBoundryT</span> <span class="o">=</span> <span class="n">dataBoundryT</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">return</span><span class="p">(</span><span class="n">dataBoundryHs</span><span class="p">,</span> <span class="n">dataBoundryT</span><span class="p">)</span></div>
    


    <span class="k">def</span> <span class="nf">__getCopulaParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n_size</span><span class="p">,</span><span class="n">bin_1_limit</span><span class="p">,</span><span class="n">bin_step</span><span class="p">):</span>
        <span class="n">sorted_idx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="n">Hs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>

        <span class="c1"># Estimate parameters for Weibull distribution for component 1 (Hs) using MLE</span>
        <span class="c1"># Estimate parameters for Lognormal distribution for component 2 (T) using MLE</span>
        <span class="n">para_dist_1</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">exponweib</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span><span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">fa</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">para_dist_2</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>

        <span class="c1"># Binning</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span><span class="nb">sum</span><span class="p">(</span><span class="n">Hs_val</span> <span class="o">&lt;=</span> <span class="n">bin_1_limit</span> <span class="k">for</span> <span class="n">Hs_val</span> <span class="ow">in</span> <span class="n">Hs</span><span class="p">))</span>
        <span class="c1"># Make sure first bin isn&#39;t empty or too small to avoid errors        </span>
        <span class="k">while</span> <span class="n">ind</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="n">n_size</span><span class="p">:</span>         
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>    
            <span class="n">bin_1_limit</span> <span class="o">=</span> <span class="n">bin_1_limit</span> <span class="o">+</span> <span class="n">bin_step</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span><span class="nb">sum</span><span class="p">(</span><span class="n">Hs_val</span> <span class="o">&lt;=</span> <span class="n">bin_1_limit</span> <span class="k">for</span> <span class="n">Hs_val</span> <span class="ow">in</span> <span class="n">Hs</span><span class="p">))</span>        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">200</span><span class="p">):</span>
            <span class="n">bin_i_limit</span> <span class="o">=</span> <span class="n">bin_1_limit</span><span class="o">+</span><span class="n">bin_step</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span><span class="nb">sum</span><span class="p">(</span><span class="n">Hs_val</span> <span class="o">&lt;=</span> <span class="n">bin_i_limit</span> <span class="k">for</span> <span class="n">Hs_val</span> <span class="ow">in</span> <span class="n">Hs</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">n_size</span><span class="p">:</span>
                <span class="k">break</span>
    
        <span class="c1"># Parameters for conditional distribution of T|Hs for each bin</span>
        <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="c1"># num+1: number of bins</span>
        <span class="n">para_dist_cond</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hss</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">para_dist_cond</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]))])))</span>  <span class="c1"># parameters for first bin</span>
        <span class="n">hss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hs</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">)]))</span> <span class="c1"># mean of Hs (component 1 for first bin)</span>
        <span class="n">para_dist_cond</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]))])))</span> <span class="c1"># parameters for second bin</span>
        <span class="n">hss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hs</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">)]))</span> <span class="c1"># mean of Hs (component 1 for second bin)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">num</span><span class="p">):</span>
            <span class="n">para_dist_cond</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]))])));</span>
            <span class="n">hss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hs</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]))]))</span>

        <span class="c1"># Estimate coefficient using least square solution (mean: third order, sigma: 2nd order)</span>
        <span class="n">para_dist_cond</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">num</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Hs</span><span class="p">)))])));</span>  <span class="c1"># parameters for last bin</span>
        <span class="n">hss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hs</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">num</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Hs</span><span class="p">)))]))</span> <span class="c1"># mean of Hs (component 1 for last bin)</span>

        <span class="n">para_dist_cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">para_dist_cond</span><span class="p">)</span>
        <span class="n">hss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hss</span><span class="p">)</span>

        <span class="n">phi_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">hss</span><span class="p">[:],</span><span class="n">hss</span><span class="p">[:]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">hss</span><span class="p">[:]</span><span class="o">**</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">phi_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">hss</span><span class="p">[:],</span><span class="n">hss</span><span class="p">[:]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Estimate coefficients of mean of Ln(T|Hs)(vector 4x1) (cubic in Hs)</span>
        <span class="n">mean_cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">phi_mean</span><span class="p">,</span><span class="n">para_dist_cond</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Estimate coefficients of standard deviation of Ln(T|Hs) (vector 3x1) (quadratic in Hs)</span>
        <span class="n">std_cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">phi_std</span><span class="p">,</span><span class="n">para_dist_cond</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">para_dist_1</span><span class="p">,</span> <span class="n">para_dist_2</span><span class="p">,</span> <span class="n">mean_cond</span><span class="p">,</span> <span class="n">std_cond</span>
        
    <span class="k">def</span> <span class="nf">__getNonParaCopulaParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Ndata</span><span class="p">,</span> <span class="n">max_T</span><span class="p">,</span> <span class="n">max_Hs</span><span class="p">):</span>
        <span class="n">sorted_idx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="n">Hs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>
        
        <span class="c1"># Calcualte KDE bounds (this may be added as an input later)</span>
        <span class="n">min_limit_1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_limit_1</span> <span class="o">=</span> <span class="n">max_Hs</span>
        <span class="n">min_limit_2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_limit_2</span> <span class="o">=</span> <span class="n">max_T</span>   
        
        <span class="c1"># Discretize for KDE</span>
        <span class="n">pts_hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_limit_1</span><span class="p">,</span> <span class="n">max_limit_1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">)</span> 
        <span class="n">pts_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_limit_2</span><span class="p">,</span> <span class="n">max_limit_2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">)</span>
        
        <span class="c1"># Calculate optimal bandwidth for T and Hs</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">robust</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">mad</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
        <span class="n">bwT</span> <span class="o">=</span> <span class="n">sig</span><span class="o">*</span><span class="p">(</span><span class="mf">4.0</span><span class="o">/</span><span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">num</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">5.0</span><span class="p">)</span>
        
        <span class="n">sig</span> <span class="o">=</span> <span class="n">robust</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">mad</span><span class="p">(</span><span class="n">Hs</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Hs</span><span class="p">))</span>
        <span class="n">bwHs</span> <span class="o">=</span> <span class="n">sig</span><span class="o">*</span><span class="p">(</span><span class="mf">4.0</span><span class="o">/</span><span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">num</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">5.0</span><span class="p">)</span>
        
        <span class="c1"># Nonparametric PDF for T</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">nonparametric</span><span class="o">.</span><span class="n">KDEUnivariate</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="n">temp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">bw</span> <span class="o">=</span> <span class="n">bwT</span><span class="p">)</span>
        <span class="n">f_t</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">pts_t</span><span class="p">)</span>
        
        <span class="c1"># Nonparametric CDF for Hs</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">nonparametric</span><span class="o">.</span><span class="n">KDEUnivariate</span><span class="p">(</span><span class="n">Hs</span><span class="p">)</span>
        <span class="n">temp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">bw</span> <span class="o">=</span> <span class="n">bwHs</span><span class="p">)</span>
        <span class="n">tempPDF</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">pts_hs</span><span class="p">)</span>
        <span class="n">F_hs</span> <span class="o">=</span> <span class="n">tempPDF</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">tempPDF</span><span class="p">)</span>
        <span class="n">F_hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">F_hs</span><span class="p">)</span>
        
        <span class="c1"># Nonparametric CDF for T</span>
        <span class="n">F_t</span> <span class="o">=</span> <span class="n">f_t</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">f_t</span><span class="p">)</span>
        <span class="n">F_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">F_t</span><span class="p">)</span>
        
        <span class="n">nonpara_dist_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pts_hs</span><span class="p">,</span> <span class="n">F_hs</span><span class="p">]))</span>
        <span class="n">nonpara_dist_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pts_t</span><span class="p">,</span> <span class="n">F_t</span><span class="p">]))</span>
        <span class="n">nonpara_pdf_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pts_t</span><span class="p">,</span> <span class="n">f_t</span><span class="p">]))</span>
        
        <span class="k">return</span> <span class="n">nonpara_dist_1</span><span class="p">,</span> <span class="n">nonpara_dist_2</span><span class="p">,</span> <span class="n">nonpara_pdf_2</span>
        
    <span class="k">def</span> <span class="nf">__gumbelCopula</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Calculates the Gumbel copula density</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u: np.array</span>
<span class="sd">                    Vector of equally spaced points between 0 and twice the</span>
<span class="sd">                    maximum value of T.</span>
<span class="sd">        alpha: float</span>
<span class="sd">                    Copula parameter. Must be greater than or equal to 1.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y: np.array</span>
<span class="sd">                   Copula density function.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#Ignore divide by 0 warnings and resulting NaN warnings</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>        
        <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">nlogC</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">vmin</span> <span class="o">/</span> <span class="n">vmax</span><span class="p">)</span> <span class="o">**</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span><span class="n">nlogC</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">nlogC</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">alpha</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">+</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nlogC</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">)</span>

        <span class="k">return</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>        </div>

<div class="viewcode-block" id="PCA"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.PCA">[docs]</a><span class="k">class</span> <span class="nc">PCA</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">size_bin</span><span class="o">=</span><span class="mf">250.</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a PCA EA class for a buoy object. Contours generated under this</span>
<span class="sd">        class will use principal component analysis (PCA) with improved </span>
<span class="sd">        distribution fitting (Eckert et. al 2015) and the I-FORM.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">            size_bin : float</span>
<span class="sd">                chosen bin size</span>
<span class="sd">            buoy : NDBCData</span>
<span class="sd">                ESSC.Buoy Object</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Principle component analysis&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span> <span class="o">=</span> <span class="n">buoy</span>
        <span class="k">if</span> <span class="n">size_bin</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span><span class="o">*</span><span class="mf">0.25</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size_bin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span><span class="o">*</span><span class="mf">0.25</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span><span class="o">*</span><span class="mf">0.25</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="s1">&#39;is the max bin size for this buoy. The bin size has been set to this amount.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size_bin</span> <span class="o">=</span> <span class="n">size_bin</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleCA</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleFSS</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_SampleCA</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_SampleFSS</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Weight_points</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generateParams</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size_bin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__generateParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size_bin</span><span class="o">=</span><span class="mf">250.0</span><span class="p">):</span>
        <span class="n">pca</span> <span class="o">=</span> <span class="n">skPCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">components_</span><span class="p">)</span>  <span class="c1"># Apply correct/expected sign convention</span>
        <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># Apply correct/expected sign convention</span>

        <span class="n">Comp1_Comp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>

        <span class="n">shift</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">Comp1_Comp2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="mf">0.1</span>  <span class="c1"># Calculate shift</span>


        <span class="n">shift</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">Comp1_Comp2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="mf">0.1</span>  <span class="c1"># Calculate shift</span>
        <span class="c1"># Apply shift to Component 2 to make all values positive</span>
        <span class="n">Comp1_Comp2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Comp1_Comp2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span>

        <span class="n">Comp1_Comp2_sort</span> <span class="o">=</span> <span class="n">Comp1_Comp2</span><span class="p">[</span><span class="n">Comp1_Comp2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(),</span> <span class="p">:]</span>

        <span class="c1"># Fitting distribution of component 1</span>
        <span class="n">comp1_params</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgauss</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Comp1_Comp2_sort</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">n_data</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span>  <span class="c1"># Number of observations</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size_bin</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_data</span> <span class="o">/</span> <span class="n">size_bin</span><span class="p">),</span>
                         <span class="n">size_bin</span><span class="p">),</span> <span class="n">n_data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_data</span><span class="p">)</span>
        <span class="n">hist_count</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">ranks</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span>
        <span class="n">bin_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">ranks</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">Comp2_bins_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">bin_inds</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">Comp1_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="k">for</span> <span class="n">bin_loop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bin_inds</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">mask_bins</span> <span class="o">=</span> <span class="n">bin_inds</span> <span class="o">==</span> <span class="n">bin_loop</span>  <span class="c1"># Find location of bin values</span>
            <span class="n">Comp2_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">Comp1_Comp2_sort</span><span class="p">[</span><span class="n">mask_bins</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">Comp1_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Comp1_mean</span><span class="p">,</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Comp1_Comp2_sort</span><span class="p">[</span><span class="n">mask_bins</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="c1"># Calcualte normal distribution parameters for C2 in each bin</span>
            <span class="n">Comp2_bins_params</span><span class="p">[:,</span> <span class="n">bin_loop</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Comp2_bin</span><span class="p">))</span>

        <span class="n">mu_param</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__mu_fcn</span><span class="p">,</span>
                                                 <span class="n">Comp1_mean</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Comp2_bins_params</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>

        <span class="n">sigma_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sigma_fits</span><span class="p">(</span><span class="n">Comp1_mean</span><span class="p">,</span> <span class="n">Comp2_bins_params</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">return</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">comp1_params</span><span class="p">,</span> <span class="n">sigma_param</span><span class="p">,</span> <span class="n">mu_param</span>

    <span class="k">def</span> <span class="nf">_saveParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupObj</span><span class="p">):</span>
        <span class="k">if</span><span class="p">(</span><span class="s1">&#39;nb_steps&#39;</span> <span class="ow">in</span> <span class="n">groupObj</span><span class="p">):</span>
            <span class="n">groupObj</span><span class="p">[</span><span class="s1">&#39;nb_steps&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;nb_steps&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span><span class="p">)</span>
        
        <span class="k">if</span><span class="p">(</span><span class="s1">&#39;time_r&#39;</span> <span class="ow">in</span> <span class="n">groupObj</span><span class="p">):</span>
            <span class="n">groupObj</span><span class="p">[</span><span class="s1">&#39;time_r&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;time_r&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_r</span><span class="p">)</span>
        
        <span class="k">if</span><span class="p">(</span><span class="s1">&#39;time_ss&#39;</span> <span class="ow">in</span> <span class="n">groupObj</span><span class="p">):</span>
            <span class="n">groupObj</span><span class="p">[</span><span class="s1">&#39;time_ss&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span>
        <span class="k">else</span><span class="p">:</span>       
            <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;time_ss&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span><span class="p">)</span>

        <span class="k">if</span><span class="p">(</span><span class="s1">&#39;coeff&#39;</span> <span class="ow">in</span> <span class="n">groupObj</span><span class="p">):</span>
            <span class="n">groupObj</span><span class="p">[</span><span class="s1">&#39;coeff&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;coeff&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
        
        <span class="k">if</span><span class="p">(</span><span class="s1">&#39;shift&#39;</span> <span class="ow">in</span> <span class="n">groupObj</span><span class="p">):</span>
            <span class="n">groupObj</span><span class="p">[</span><span class="s1">&#39;shift&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;shift&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span>
        
        <span class="k">if</span><span class="p">(</span><span class="s1">&#39;comp1_params&#39;</span> <span class="ow">in</span> <span class="n">groupObj</span><span class="p">):</span>
            <span class="n">groupObj</span><span class="p">[</span><span class="s1">&#39;comp1_params&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;comp1_params&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">)</span>
        
        <span class="k">if</span><span class="p">(</span><span class="s1">&#39;sigma_param&#39;</span> <span class="ow">in</span> <span class="n">groupObj</span><span class="p">):</span>
            <span class="n">groupObj</span><span class="p">[</span><span class="s1">&#39;sigma_param&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_param</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;sigma_param&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_param</span><span class="p">)</span>
        
        <span class="k">if</span><span class="p">(</span><span class="s1">&#39;mu_param&#39;</span> <span class="ow">in</span> <span class="n">groupObj</span><span class="p">):</span>
            <span class="n">groupObj</span><span class="p">[</span><span class="s1">&#39;mu_param&#39;</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;mu_param&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span><span class="p">)</span>

<div class="viewcode-block" id="PCA.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.PCA.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ss</span><span class="p">,</span> <span class="n">time_r</span><span class="p">,</span> <span class="n">nb_steps</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State PCA Contour function</span>
<span class="sd">        This function calculates environmental contours of extreme sea states using</span>
<span class="sd">        principal component analysis and the inverse first-order reliability</span>
<span class="sd">        method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">        time_ss : float</span>
<span class="sd">            Sea state duration (hours) of measurements in input.</span>
<span class="sd">        time_r : np.array</span>
<span class="sd">            Desired return period (years) for calculation of environmental</span>
<span class="sd">            contour, can be a scalar or a vector.</span>
<span class="sd">        nb_steps : int</span>
<span class="sd">            Discretization of the circle in the normal space used for</span>
<span class="sd">            inverse FORM calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Return : np.array</span>
<span class="sd">            Calculated Hs values along the contour boundary following</span>
<span class="sd">            return to original input orientation.</span>
<span class="sd">        T_Return : np.array</span>
<span class="sd">           Calculated T values along the contour boundary following</span>
<span class="sd">           return to original input orientation.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To obtain the contours for a NDBC buoy::</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            </span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            </span>
<span class="sd">            # Create PCA EA object for buoy</span>
<span class="sd">            pca46022 = ESSC.PCA(buoy46022)</span>
<span class="sd">            </span>
<span class="sd">            # Declare required parameters</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = 100  # Return periods (yrs) of interest</span>
<span class="sd">            nb_steps = 1000  # Enter discretization of the circle in the normal space (optional)</span>
<span class="sd">            </span>
<span class="sd">            # Contour generation example</span>
<span class="sd">            Hs_Return, T_Return = pca46022.getContours(Time_SS, Time_r,nb_steps)</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span> <span class="o">=</span> <span class="n">time_ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span> <span class="o">=</span> <span class="n">time_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span> <span class="o">=</span> <span class="n">nb_steps</span>

        <span class="c1"># IFORM</span>
        <span class="c1"># Failure probability for the desired return period (time_R) given the</span>
        <span class="c1"># duration of the measurements (time_ss)</span>
        <span class="n">p_f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_r</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_f</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reliability</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nb_steps</span><span class="p">)</span>
        <span class="c1"># Vary U1, U2 along circle sqrt(U1^2+U2^2)=beta</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="c1"># Calculate C1 values along the contour</span>
        <span class="n">Comp1_R</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgauss</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                     <span class="n">mu</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                     <span class="n">scale</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1"># Calculate mu values at each point on the circle</span>
        <span class="n">mu_R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mu_fcn</span><span class="p">(</span><span class="n">Comp1_R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Calculate sigma values at each point on the circle</span>
        <span class="n">sigma_R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sigma_fcn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_param</span><span class="p">,</span> <span class="n">Comp1_R</span><span class="p">)</span>
        <span class="c1"># Use calculated mu and sigma values to calculate C2 along the contour</span>
        <span class="n">Comp2_R</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                 <span class="n">loc</span><span class="o">=</span><span class="n">mu_R</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma_R</span><span class="p">)</span>

        <span class="c1"># Calculate Hs and T along the contour</span>
        <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__princomp_inv</span><span class="p">(</span><span class="n">Comp1_R</span><span class="p">,</span> <span class="n">Comp2_R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span>
        <span class="n">Hs_Return</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Hs_Return</span><span class="p">)</span>  <span class="c1"># Remove negative values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="n">Hs_Return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="n">T_Return</span>
        <span class="k">return</span> <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span></div>

<div class="viewcode-block" id="PCA.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.PCA.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_contour_points</span><span class="p">,</span> <span class="n">contour_returns</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State Contour Sampling function.</span>
<span class="sd">        This function calculates samples of Hs and T using the EA function to</span>
<span class="sd">        sample between contours of user-defined return periods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num_contour_points : int</span>
<span class="sd">            Number of sample points to be calculated per contour interval.</span>
<span class="sd">        contour_returns: np.array</span>
<span class="sd">            Vector of return periods that define the contour intervals in</span>
<span class="sd">            which samples will be taken. Values must be greater than zero and</span>
<span class="sd">            must be in increasing order.</span>
<span class="sd">        random_seed: int (optional)</span>
<span class="sd">            Random seed for sample generation, required for sample</span>
<span class="sd">            repeatability. If left blank, a seed will automatically be</span>
<span class="sd">            generated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Samples: np.array</span>
<span class="sd">            Vector of Hs values for each sample point.</span>
<span class="sd">        Te_Samples: np.array</span>
<span class="sd">            Vector of Te values for each sample point.</span>
<span class="sd">        Weight_points: np.array</span>
<span class="sd">            Vector of probabilistic weights for each sampling point</span>
<span class="sd">            to be used in risk calculations.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To get weighted samples from a set of contours::</span>

<span class="sd">                import numpy as np</span>
<span class="sd">                import WDRT.ESSC as ESSC</span>
<span class="sd">                </span>
<span class="sd">                # Pull spectral data from NDBC website</span>
<span class="sd">                buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">                buoy46022.fetchFromWeb()</span>
<span class="sd">                </span>
<span class="sd">                # Create PCA EA object for buoy</span>
<span class="sd">                pca46022 = ESSC.PCA(buoy46022)</span>
<span class="sd">                </span>
<span class="sd">                # Declare required parameters</span>
<span class="sd">                Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">                Time_r = 100  # Return periods (yrs) of interest</span>
<span class="sd">                num_contour_points = 10 # Number of points to be sampled for each contour interval</span>
<span class="sd">                contour_returns = np.array([0.001, 0.01, 0.05, 0.1, 0.5, 1, 5, 10, 50, 100])</span>
<span class="sd">                </span>
<span class="sd">                # Calculate contour to save required variables to PCA EA object</span>
<span class="sd">                pca46022.getContours(Time_SS, Time_r,nb_steps)</span>
<span class="sd">                </span>
<span class="sd">                # Probabilities defining sampling contour bounds.</span>
<span class="sd">                random_seed = 2  # Random seed for sample generation</span>
<span class="sd">                </span>
<span class="sd">                # Get samples for a full sea state long term analysis</span>
<span class="sd">                Hs_sampleFSS, T_sampleFSS, Weight_sampleFSS = pca46022.getSamples(num_contour_points,</span>
<span class="sd">                                                             contour_returns, random_seed)</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Calculate line where Hs = 0 to avoid sampling Hs in negative space</span>
        <span class="n">Te_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">Te_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Te_zeroline</span><span class="p">)</span>
        <span class="n">Hs_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Te_zeroline</span><span class="p">))</span>

        <span class="c1"># Transform zero line into principal component space</span>
        <span class="n">Comp_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">Hs_zeroline</span><span class="p">,</span> <span class="n">Te_zeroline</span><span class="p">])),</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
        <span class="n">Comp_zeroline</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Comp_zeroline</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span>

        <span class="c1"># Find quantiles along zero line</span>
        <span class="n">C1_zeroline_prob</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgauss</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Comp_zeroline</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                                              <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                              <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">mu_zeroline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mu_fcn</span><span class="p">(</span><span class="n">Comp_zeroline</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">sigma_zeroline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sigma_fcn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_param</span><span class="p">,</span> <span class="n">Comp_zeroline</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">C2_zeroline_prob</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Comp_zeroline</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                                          <span class="n">loc</span><span class="o">=</span><span class="n">mu_zeroline</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma_zeroline</span><span class="p">)</span>
        <span class="n">C1_normzeroline</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">C1_zeroline_prob</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">C2_normzeroline</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">C2_zeroline_prob</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">contour_probs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">contour_returns</span><span class="p">)</span>
        <span class="c1"># Reliability contour generation</span>
        <span class="n">beta_lines</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">contour_probs</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Calculate reliability</span>
        <span class="n">beta_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta_lines</span><span class="p">))</span>  <span class="c1"># Add zero as lower bound to first</span>
        <span class="c1"># contour</span>
        <span class="n">theta_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  <span class="c1"># Discretize the circle</span>

        <span class="n">contour_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">contour_probs</span><span class="p">))</span>  <span class="c1"># Add probablity of 1 to the</span>
        <span class="c1"># reliability set, corresponding to probability of the center point of the</span>
        <span class="c1"># normal space</span>

        <span class="c1"># Vary U1,U2 along circle sqrt(U1^2+U2^2) = beta</span>
        <span class="n">U1_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_lines</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]),</span> <span class="n">beta_lines</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">U2_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_lines</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]),</span> <span class="n">beta_lines</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>

        <span class="c1"># Removing values on the H_s = 0 line that are far from the circles in the</span>
        <span class="c1"># normal space that will be evaluated to speed up calculations</span>
        <span class="n">minval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">U1_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">C1_normzeroline</span> <span class="o">&gt;</span> <span class="n">minval</span>
        <span class="n">C1_normzeroline</span> <span class="o">=</span> <span class="n">C1_normzeroline</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">C2_normzeroline</span> <span class="o">=</span> <span class="n">C2_normzeroline</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="c1"># Transform to polar coordinates</span>
        <span class="n">Theta_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">C2_normzeroline</span><span class="p">,</span> <span class="n">C1_normzeroline</span><span class="p">)</span>
        <span class="n">Rho_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">C1_normzeroline</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">C2_normzeroline</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">Theta_zeroline</span><span class="p">[</span><span class="n">Theta_zeroline</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Theta_zeroline</span><span class="p">[</span>
            <span class="n">Theta_zeroline</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>


        <span class="n">Sample_alpha</span><span class="p">,</span> <span class="n">Sample_beta</span><span class="p">,</span> <span class="n">Weight_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generateData</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">,</span>
            <span class="n">Rho_zeroline</span><span class="p">,</span> <span class="n">Theta_zeroline</span><span class="p">,</span> <span class="n">num_contour_points</span><span class="p">,</span><span class="n">contour_probs</span><span class="p">,</span><span class="n">random_seed</span><span class="p">)</span>

        <span class="n">Hs_Sample</span><span class="p">,</span> <span class="n">T_Sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transformSamples</span><span class="p">(</span><span class="n">Sample_alpha</span><span class="p">,</span> <span class="n">Sample_beta</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleFSS</span> <span class="o">=</span> <span class="n">Hs_Sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_SampleFSS</span> <span class="o">=</span> <span class="n">T_Sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Weight_SampleFSS</span> <span class="o">=</span> <span class="n">Weight_points</span>

        <span class="k">return</span> <span class="n">Hs_Sample</span><span class="p">,</span> <span class="n">T_Sample</span><span class="p">,</span> <span class="n">Weight_points</span></div>
    
<div class="viewcode-block" id="PCA.plotSampleData"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.PCA.plotSampleData">[docs]</a>    <span class="k">def</span> <span class="nf">plotSampleData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display a plot of the 100-year return contour, full sea state samples</span>
<span class="sd">        and contour samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">,</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;NDBC data&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;100 year contour&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_SampleFSS</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleFSS</span><span class="p">,</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;full sea state samples&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_SampleCA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleCA</span><span class="p">,</span> <span class="s1">&#39;y^&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;contour approach samples&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;small&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Energy period, $T_e$ [s]&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Sig. wave height, $H_s$ [m]&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> </div>

    <span class="k">def</span> <span class="nf">__generateData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta_lines</span><span class="p">,</span> <span class="n">Rho_zeroline</span><span class="p">,</span> <span class="n">Theta_zeroline</span><span class="p">,</span> <span class="n">num_contour_points</span><span class="p">,</span> <span class="n">contour_probs</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates radius, angle, and weight for each sample point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="sd">&#39;&#39;&#39; Data generating function that calculates the radius, angle, and</span>
<span class="sd">        weight for each sample point.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        beta_lines: np.array</span>
<span class="sd">               Array of mu fitting function parameters.</span>
<span class="sd">        Rho_zeroline: np.array</span>
<span class="sd">               array of radii</span>
<span class="sd">        Theta_zeroline: np.array</span>
<span class="sd">        num_contour_points: np.array</span>
<span class="sd">        contour_probs: np.array</span>
<span class="sd">        random_seed: int</span>
<span class="sd">            seed for generating random data.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Sample_alpha: np.array</span>
<span class="sd">                Array of fitted sample angle values.</span>
<span class="sd">        Sample_beta: np.array</span>
<span class="sd">                Array of fitted sample radius values.</span>
<span class="sd">        Weight_points: np.array</span>
<span class="sd">                Array of weights for each point.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>

        <span class="n">num_samples</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_contour_points</span>
        <span class="n">Alpha_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">Angular_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Angular_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_contour_points</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">Weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Sample_beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="n">Sample_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="n">Weight_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Loop over contour intervals</span>
            <span class="c1"># Check if any of the radii for the</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">Rho_zeroline</span> <span class="o">-</span> <span class="n">beta_lines</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Hs=0, line are smaller than the radii of the contour, meaning</span>
            <span class="c1"># that these lines intersect</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.01</span><span class="p">))</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.01</span><span class="p">))</span>
                <span class="n">Alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Theta_zeroline</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">Theta_zeroline</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">-</span>
                                      <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  <span class="c1"># Save sampling bounds</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
                            <span class="c1"># Find the angular distance that will be covered by sampling the disc</span>
            <span class="n">Angular_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="c1"># Calculate ratio of area covered for each contour</span>
            <span class="n">Angular_ratio</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Angular_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="c1"># Discretize the remaining portion of the disc into 10 equally spaced</span>
            <span class="c1"># areas to be sampled</span>
            <span class="n">Alpha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">Alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                    <span class="nb">max</span><span class="p">(</span><span class="n">Alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">Angular_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">num_contour_points</span><span class="p">)</span>
            <span class="c1"># Calculate the weight of each point sampled per contour</span>
            <span class="n">Weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">contour_probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">contour_probs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span>
                         <span class="n">Angular_ratio</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">num_contour_points</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_contour_points</span><span class="p">):</span>
                <span class="c1"># Generate sample radius by adding a randomly sampled distance to</span>
                <span class="c1"># the &#39;disc&#39; lower bound</span>
                <span class="n">Sample_beta</span><span class="p">[(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_contour_points</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta_lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>
                                                             <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">beta_lines</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">beta_lines</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="c1"># Generate sample angle by adding a randomly sampled distance to</span>
                <span class="c1"># the lower bound of the angle defining a discrete portion of the</span>
                <span class="c1"># &#39;disc&#39;</span>
                <span class="n">Sample_alpha</span><span class="p">[(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_contour_points</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Alpha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span>
                                                              <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">Alpha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Alpha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                <span class="c1"># Save the weight for each sample point</span>
                <span class="n">Weight_points</span><span class="p">[(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_contour_points</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Sample_alpha</span><span class="p">,</span> <span class="n">Sample_beta</span><span class="p">,</span> <span class="n">Weight_points</span>

    <span class="k">def</span> <span class="nf">__transformSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Sample_alpha</span><span class="p">,</span> <span class="n">Sample_beta</span><span class="p">):</span>
        <span class="n">Sample_U1</span> <span class="o">=</span> <span class="n">Sample_beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Sample_alpha</span><span class="p">)</span>
        <span class="n">Sample_U2</span> <span class="o">=</span> <span class="n">Sample_beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Sample_alpha</span><span class="p">)</span>

        <span class="c1"># Sample transformation to principal component space</span>
        <span class="n">Comp1_sample</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgauss</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Sample_U1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                          <span class="n">mu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                          <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">mu_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mu_fcn</span><span class="p">(</span><span class="n">Comp1_sample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Calculate sigma values at each point on the circle</span>
        <span class="n">sigma_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sigma_fcn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_param</span><span class="p">,</span> <span class="n">Comp1_sample</span><span class="p">)</span>
        <span class="c1"># Use calculated mu and sigma values to calculate C2 along the contour</span>
        <span class="n">Comp2_sample</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Sample_U2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                      <span class="n">loc</span><span class="o">=</span><span class="n">mu_sample</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma_sample</span><span class="p">)</span>
        <span class="c1"># Sample transformation into Hs-T space</span>
        <span class="n">Hs_Sample</span><span class="p">,</span> <span class="n">T_Sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__princomp_inv</span><span class="p">(</span>
            <span class="n">Comp1_sample</span><span class="p">,</span> <span class="n">Comp2_sample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Hs_Sample</span><span class="p">,</span> <span class="n">T_Sample</span>


    <span class="k">def</span> <span class="nf">__mu_fcn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mu_p_1</span><span class="p">,</span> <span class="n">mu_p_2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Linear fitting function for the mean(mu) of Component 2 normal</span>
<span class="sd">        distribution as a function of the Component 1 mean for each bin.</span>
<span class="sd">        Used in the EA and getSamples functions.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu_p: np.array</span>
<span class="sd">               Array of mu fitting function parameters.</span>
<span class="sd">        x: np.array</span>
<span class="sd">           Array of values (Component 1 mean for each bin) at which to evaluate</span>
<span class="sd">           the mu fitting function.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mu_fit: np.array</span>
<span class="sd">                Array of fitted mu values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">mu_fit</span> <span class="o">=</span> <span class="n">mu_p_1</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">mu_p_2</span>
        <span class="k">return</span> <span class="n">mu_fit</span>


    <span class="k">def</span> <span class="nf">__sigma_fcn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sig_p</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Quadratic fitting formula for the standard deviation(sigma) of Component</span>
<span class="sd">        2 normal distribution as a function of the Component 1 mean for each bin.</span>
<span class="sd">        Used in the EA and getSamples functions.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sig_p: np.array</span>
<span class="sd">               Array of sigma fitting function parameters.</span>
<span class="sd">        x: np.array</span>
<span class="sd">           Array of values (Component 1 mean for each bin) at which to evaluate</span>
<span class="sd">           the sigma fitting function.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sigma_fit: np.array</span>
<span class="sd">                   Array of fitted sigma values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">sigma_fit</span> <span class="o">=</span> <span class="n">sig_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sig_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sig_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sigma_fit</span>


    <span class="k">def</span> <span class="nf">__princomp_inv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">princip_data1</span><span class="p">,</span> <span class="n">princip_data2</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Takes the inverse of the principal component rotation given data,</span>
<span class="sd">        coefficients, and shift. Used in the EA and getSamples functions.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        princip_data1: np.array</span>
<span class="sd">                       Array of Component 1 values.</span>
<span class="sd">        princip_data2: np.array</span>
<span class="sd">                       Array of Component 2 values.</span>
<span class="sd">        coeff: np.array</span>
<span class="sd">               Array of principal component coefficients.</span>
<span class="sd">        shift: float</span>
<span class="sd">               Shift applied to Component 2 to make all values positive.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        original1: np.array</span>
<span class="sd">                   Hs values following rotation from principal component space.</span>
<span class="sd">        original2: np.array</span>
<span class="sd">                   T values following rotation from principal component space.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">original1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">princip_data1</span><span class="p">))</span>
        <span class="n">original2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">princip_data1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">princip_data2</span><span class="p">)):</span>
            <span class="n">original1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(((</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">princip_data2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span> <span class="o">+</span>
                             <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">princip_data1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                                                  <span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">original2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(((</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">princip_data1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span>
                             <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">princip_data2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
                                             <span class="n">shift</span><span class="p">)))</span> <span class="o">/</span> <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">original1</span><span class="p">,</span> <span class="n">original2</span>

    <span class="k">def</span> <span class="nf">__betafcn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig_p</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Penalty calculation for sigma parameter fitting function to impose</span>
<span class="sd">        positive value constraint.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sig_p: np.array</span>
<span class="sd">               Array of sigma fitting function parameters.</span>
<span class="sd">        rho: float</span>
<span class="sd">             Penalty function variable that drives the solution towards</span>
<span class="sd">             required constraint.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Beta1: float</span>
<span class="sd">               Penalty function variable that applies the constraint requiring</span>
<span class="sd">               the y-intercept of the sigma fitting function to be greater than</span>
<span class="sd">               or equal to 0.</span>
<span class="sd">        Beta2: float</span>
<span class="sd">               Penalty function variable that applies the constraint requiring</span>
<span class="sd">               the minimum of the sigma fitting function to be greater than or</span>
<span class="sd">               equal to 0.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">sig_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Beta1</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Beta1</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">sig_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">sig_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">sig_p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Beta2</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Beta2</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="k">return</span> <span class="n">Beta1</span><span class="p">,</span> <span class="n">Beta2</span>

    <span class="c1"># Sigma function sigma_fcn defined outside of EA function</span>

    <span class="k">def</span> <span class="nf">__objfun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y_actual</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Sum of least square error objective function used in sigma</span>
<span class="sd">        minimization.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sig_p: np.array</span>
<span class="sd">               Array of sigma fitting function parameters.</span>
<span class="sd">        x: np.array</span>
<span class="sd">           Array of values (Component 1 mean for each bin) at which to evaluate</span>
<span class="sd">           the sigma fitting function.</span>
<span class="sd">        y_actual: np.array</span>
<span class="sd">                  Array of actual sigma values for each bin to use in least</span>
<span class="sd">                  square error calculation with fitted values.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj_fun_result: float</span>
<span class="sd">                        Sum of least square error objective function for fitted</span>
<span class="sd">                        and actual values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">obj_fun_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__sigma_fcn</span><span class="p">(</span><span class="n">sig_p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">y_actual</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj_fun_result</span>  <span class="c1"># Sum of least square error</span>

    <span class="k">def</span> <span class="nf">__objfun_penalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y_actual</span><span class="p">,</span> <span class="n">Beta1</span><span class="p">,</span> <span class="n">Beta2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Penalty function used for sigma function constrained optimization.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sig_p: np.array</span>
<span class="sd">               Array of sigma fitting function parameters.</span>
<span class="sd">        x: np.array</span>
<span class="sd">           Array of values (Component 1 mean for each bin) at which to evaluate</span>
<span class="sd">           the sigma fitting function.</span>
<span class="sd">        y_actual: np.array</span>
<span class="sd">                  Array of actual sigma values for each bin to use in least</span>
<span class="sd">                  square error calculation with fitted values.</span>
<span class="sd">        Beta1: float</span>
<span class="sd">               Penalty function variable that applies the constraint requiring</span>
<span class="sd">               the y-intercept of the sigma fitting function to be greater than</span>
<span class="sd">               or equal to 0.</span>
<span class="sd">        Beta2: float</span>
<span class="sd">               Penalty function variable that applies the constraint requiring</span>
<span class="sd">               the minimum of the sigma fitting function to be greater than or</span>
<span class="sd">               equal to 0.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        penalty_fcn: float</span>
<span class="sd">                     Objective function result with constraint penalties</span>
<span class="sd">                     applied for out of bound solutions.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">penalty_fcn</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__objfun</span><span class="p">(</span><span class="n">sig_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y_actual</span><span class="p">)</span> <span class="o">+</span> <span class="n">Beta1</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">sig_p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                       <span class="n">Beta2</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">sig_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">sig_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">sig_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">penalty_fcn</span>

    <span class="k">def</span> <span class="nf">__sigma_fits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Comp1_mean</span><span class="p">,</span> <span class="n">sigma_vals</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Sigma parameter fitting function using penalty optimization.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Comp1_mean: np.array</span>
<span class="sd">                    Mean value of Component 1 for each bin of Component 2.</span>
<span class="sd">        sigma_vals: np.array</span>
<span class="sd">                    Value of Component 2 sigma for each bin derived from normal</span>
<span class="sd">                    distribution fit.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sig_final: np.array</span>
<span class="sd">                   Final sigma parameter values after constrained optimization.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">sig_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>  <span class="c1"># Set initial guess</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Set initial penalty value</span>
        <span class="c1"># Set tolerance, very small values (i.e.,smaller than 10^-5) may cause</span>
        <span class="c1"># instabilities</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">5</span>
        <span class="c1"># Set inital beta values using beta function</span>
        <span class="n">Beta1</span><span class="p">,</span> <span class="n">Beta2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__betafcn</span><span class="p">(</span><span class="n">sig_0</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>
        <span class="c1"># Initial search for minimum value using initial guess</span>
        <span class="n">sig_1</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__objfun_penalty</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">sig_0</span><span class="p">,</span>
                           <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">Comp1_mean</span><span class="p">,</span> <span class="n">sigma_vals</span><span class="p">,</span> <span class="n">Beta1</span><span class="p">,</span> <span class="n">Beta2</span><span class="p">),</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># While either the difference between iterations or the difference in</span>
        <span class="c1"># objective function evaluation is greater than the tolerance, continue</span>
        <span class="c1"># iterating</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">sig_1</span> <span class="o">-</span> <span class="n">sig_0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">epsilon</span> <span class="ow">and</span>
               <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__objfun</span><span class="p">(</span><span class="n">sig_1</span><span class="p">,</span> <span class="n">Comp1_mean</span><span class="p">,</span> <span class="n">sigma_vals</span><span class="p">)</span> <span class="o">-</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">__objfun</span><span class="p">(</span><span class="n">sig_0</span><span class="p">,</span> <span class="n">Comp1_mean</span><span class="p">,</span> <span class="n">sigma_vals</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">epsilon</span><span class="p">):</span>
            <span class="n">sig_0</span> <span class="o">=</span> <span class="n">sig_1</span>
            <span class="c1"># Calculate penalties for this iteration</span>
            <span class="n">Beta1</span><span class="p">,</span> <span class="n">Beta2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__betafcn</span><span class="p">(</span><span class="n">sig_0</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>
            <span class="c1"># Find a new minimum</span>
            <span class="n">sig_1</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__objfun_penalty</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">sig_0</span><span class="p">,</span>
                               <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">Comp1_mean</span><span class="p">,</span> <span class="n">sigma_vals</span><span class="p">,</span> <span class="n">Beta1</span><span class="p">,</span> <span class="n">Beta2</span><span class="p">),</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">rho</span>  <span class="c1"># Increase penalization</span>
        <span class="n">sig_final</span> <span class="o">=</span> <span class="n">sig_1</span>
        <span class="k">return</span> <span class="n">sig_final</span></div>


<div class="viewcode-block" id="GaussianCopula"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.GaussianCopula">[docs]</a><span class="k">class</span> <span class="nc">GaussianCopula</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Create a GaussianCopula EA class for a buoy object. Contours generated </span>
<span class="sd">    under this class will use a Gaussian copula.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">n_size</span><span class="o">=</span><span class="mf">40.</span><span class="p">,</span> <span class="n">bin_1_limit</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">bin_step</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            buoy : NDBCData</span>
<span class="sd">                ESSC.Buoy Object</span>
<span class="sd">            n_size: float</span>
<span class="sd">                minimum bin size used for Copula contour methods</span>
<span class="sd">            bin_1_limit: float</span>
<span class="sd">                maximum value of Hs for the first bin</span>
<span class="sd">            bin_step: float</span>
<span class="sd">                overlap interval for each bin</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Gaussian Copula&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span> <span class="o">=</span> <span class="n">buoy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span> <span class="o">=</span> <span class="n">n_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span> <span class="o">=</span> <span class="n">bin_1_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span> <span class="o">=</span> <span class="n">bin_step</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.Hs_SampleCA = None</span>
<span class="c1">#        self.Hs_SampleFSS = None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.T_SampleCA = None</span>
<span class="c1">#        self.T_SampleFSS = None</span>

<span class="c1">#        self.Weight_points = None</span>

<span class="c1">#        self.coeff, self.shift, self.comp1_params, self.sigma_param, self.mu_param = self.__generateParams(size_bin)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EA__getCopulaParams</span><span class="p">(</span><span class="n">n_size</span><span class="p">,</span><span class="n">bin_1_limit</span><span class="p">,</span><span class="n">bin_step</span><span class="p">)</span>

<div class="viewcode-block" id="GaussianCopula.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.GaussianCopula.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ss</span><span class="p">,</span> <span class="n">time_r</span><span class="p">,</span> <span class="n">nb_steps</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State Gaussian Copula Contour function.</span>
<span class="sd">        This function calculates environmental contours of extreme sea states using</span>
<span class="sd">        a Gaussian copula and the inverse first-order reliability</span>
<span class="sd">        method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">        time_ss : float</span>
<span class="sd">            Sea state duration (hours) of measurements in input.</span>
<span class="sd">        time_r : np.array</span>
<span class="sd">            Desired return period (years) for calculation of environmental</span>
<span class="sd">            contour, can be a scalar or a vector.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space used for</span>
<span class="sd">            inverse FORM calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Return : np.array</span>
<span class="sd">            Calculated Hs values along the contour boundary following</span>
<span class="sd">            return to original input orientation.</span>
<span class="sd">        T_Return : np.array</span>
<span class="sd">           Calculated T values along the contour boundary following</span>
<span class="sd">           return to original input orientation.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To obtain the contours for a NDBC buoy::</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            </span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            </span>
<span class="sd">            # Create Environtmal Analysis object using above parameters</span>
<span class="sd">            Gauss46022 = ESSC.GaussianCopula(buoy46022)</span>
<span class="sd">            </span>
<span class="sd">            # Declare required parameters</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = 100  # Return periods (yrs) of interest</span>
<span class="sd">            nb_steps = 1000  # Enter discretization of the circle in the normal space (optional)</span>
<span class="sd">            </span>
<span class="sd">            # Gaussian copula contour generation example</span>
<span class="sd">            Hs_Return, T_Return = Gauss46022.getContours(Time_SS, Time_r,nb_steps)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span> <span class="o">=</span> <span class="n">time_ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span> <span class="o">=</span> <span class="n">time_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span> <span class="o">=</span> <span class="n">nb_steps</span>

        <span class="n">p_f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_r</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_f</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reliability</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nb_steps</span><span class="p">)</span>
        <span class="c1"># Vary U1, U2 along circle sqrt(U1^2+U2^2)=beta</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">comp_1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">exponweib</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">),</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Calculate Kendall&#39;s tau</span>
        <span class="n">rho_gau</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">tau</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

        <span class="n">z2_Gau</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">rho_gau</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span><span class="o">+</span><span class="n">rho_gau</span><span class="o">*</span><span class="n">U1</span><span class="p">);</span>
        <span class="n">comp_2_Gaussian</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">z2_Gau</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1">#lognormalinverse</span>

        <span class="n">Hs_Return</span> <span class="o">=</span> <span class="n">comp_1</span>
        <span class="n">T_Return</span> <span class="o">=</span> <span class="n">comp_2_Gaussian</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="n">Hs_Return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="n">T_Return</span>
        <span class="k">return</span> <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span></div>

<div class="viewcode-block" id="GaussianCopula.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.GaussianCopula.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Currently not implemented in this version.&#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_saveParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupObj</span><span class="p">):</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;n_size&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_1_limit&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_step&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_1&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;mean_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;std_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rosenblatt"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Rosenblatt">[docs]</a><span class="k">class</span> <span class="nc">Rosenblatt</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Create a Rosenblatt EA class for a buoy object. Contours generated </span>
<span class="sd">    under this class will use a Rosenblatt transformation and the I-FORM.&#39;&#39;&#39;</span>    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">n_size</span><span class="o">=</span><span class="mf">50.</span><span class="p">,</span> <span class="n">bin_1_limit</span><span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">bin_step</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            buoy : NDBCData</span>
<span class="sd">                ESSC.Buoy Object</span>
<span class="sd">            n_size: float</span>
<span class="sd">                minimum bin size used for Copula contour methods</span>
<span class="sd">            bin_1_limit: float</span>
<span class="sd">                maximum value of Hs for the first bin</span>
<span class="sd">            bin_step: float</span>
<span class="sd">                overlap interval for each bin</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Rosenblatt&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span> <span class="o">=</span> <span class="n">buoy</span>
        
        <span class="k">if</span> <span class="n">n_size</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="nb">print</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="s1">&#39;is the maximum &quot;minimum bin size&quot; for this buoy. The minimum bin size has been set to this amount.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span> <span class="o">=</span> <span class="n">n_size</span>
        
        <span class="k">if</span> <span class="n">bin_step</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span><span class="o">*.</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span><span class="o">*.</span><span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span><span class="o">*.</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="s1">&#39;is the maximum bin overlap for this buoy. The bin overlap has been set to this amount.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span> <span class="o">=</span> <span class="n">bin_step</span>

        <span class="k">if</span> <span class="n">bin_1_limit</span>  <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span><span class="o">*.</span><span class="mi">25</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span><span class="o">*.</span><span class="mi">25</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span><span class="o">*.</span><span class="mi">25</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="s1">&#39;is the maximum limit for the first for this buoy. The first bin limit has been set to this amount.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span> <span class="o">=</span> <span class="n">bin_1_limit</span>           
        
        

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.Hs_SampleCA = None</span>
<span class="c1">#        self.Hs_SampleFSS = None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.T_SampleCA = None</span>
<span class="c1">#        self.T_SampleFSS = None</span>

<span class="c1">#        self.Weight_points = None</span>

<span class="c1">#        self.coeff, self.shift, self.comp1_params, self.sigma_param, self.mu_param = self.__generateParams(size_bin)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EA__getCopulaParams</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>

<div class="viewcode-block" id="Rosenblatt.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Rosenblatt.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ss</span><span class="p">,</span> <span class="n">time_r</span><span class="p">,</span> <span class="n">nb_steps</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State Rosenblatt Copula Contour function.</span>
<span class="sd">        This function calculates environmental contours of extreme sea states using</span>
<span class="sd">        a Rosenblatt transformation and the inverse first-order reliability</span>
<span class="sd">        method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">        time_ss : float</span>
<span class="sd">            Sea state duration (hours) of measurements in input.</span>
<span class="sd">        time_r : np.array</span>
<span class="sd">            Desired return period (years) for calculation of environmental</span>
<span class="sd">            contour, can be a scalar or a vector.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space used for</span>
<span class="sd">            inverse FORM calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Return : np.array</span>
<span class="sd">            Calculated Hs values along the contour boundary following</span>
<span class="sd">            return to original input orientation.</span>
<span class="sd">        T_Return : np.array</span>
<span class="sd">           Calculated T values along the contour boundary following</span>
<span class="sd">           return to original input orientation.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To obtain the contours for a NDBC buoy::</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            </span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            </span>
<span class="sd">            # Create Environtmal Analysis object using above parameters</span>
<span class="sd">            Rosen46022 = ESSC.Rosenblatt(buoy46022)</span>
<span class="sd">            </span>
<span class="sd">            # Declare required parameters</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = 100  # Return periods (yrs) of interest</span>
<span class="sd">            nb_steps = 1000  # Enter discretization of the circle in the normal space (optional)</span>
<span class="sd">            </span>
<span class="sd">            # Rosenblatt contour generation example</span>
<span class="sd">            Hs_Return, T_Return = Rosen46022.getContours(Time_SS, Time_r,nb_steps)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span> <span class="o">=</span> <span class="n">time_ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span> <span class="o">=</span> <span class="n">time_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span> <span class="o">=</span> <span class="n">nb_steps</span>

        <span class="n">p_f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_r</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_f</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reliability</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nb_steps</span><span class="p">)</span>
        <span class="c1"># Vary U1, U2 along circle sqrt(U1^2+U2^2)=beta</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">comp_1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">exponweib</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">),</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">lamda_cond</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">comp_1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">comp_1</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">comp_1</span><span class="o">**</span><span class="mi">3</span>      <span class="c1"># mean of Ln(T) as a function of Hs</span>
        <span class="n">sigma_cond</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">comp_1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">comp_1</span><span class="o">**</span><span class="mi">2</span>                                <span class="c1"># Standard deviation of Ln(T) as a function of Hs</span>

        <span class="n">comp_2_Rosenblatt</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U2</span><span class="p">),</span><span class="n">s</span><span class="o">=</span><span class="n">sigma_cond</span><span class="p">,</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lamda_cond</span><span class="p">))</span>  <span class="c1"># lognormal inverse</span>

        <span class="n">Hs_Return</span> <span class="o">=</span> <span class="n">comp_1</span>
        <span class="n">T_Return</span> <span class="o">=</span> <span class="n">comp_2_Rosenblatt</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="n">Hs_Return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="n">T_Return</span>
        <span class="k">return</span> <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span></div>

<div class="viewcode-block" id="Rosenblatt.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Rosenblatt.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Currently not implemented in this version&#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_saveParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupObj</span><span class="p">):</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;n_size&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_1_limit&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_step&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_1&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;mean_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;std_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span><span class="p">)</span></div>


<div class="viewcode-block" id="ClaytonCopula"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.ClaytonCopula">[docs]</a><span class="k">class</span> <span class="nc">ClaytonCopula</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Create a ClaytonCopula EA class for a buoy object. Contours generated </span>
<span class="sd">    under this class will use a Clayton copula.&#39;&#39;&#39;</span>    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">n_size</span><span class="o">=</span><span class="mf">40.</span><span class="p">,</span> <span class="n">bin_1_limit</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">bin_step</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            buoy : NDBCData</span>
<span class="sd">                ESSC.Buoy Object</span>
<span class="sd">            n_size: float</span>
<span class="sd">                minimum bin size used for Copula contour methods</span>
<span class="sd">            bin_1_limit: float</span>
<span class="sd">                maximum value of Hs for the first bin</span>
<span class="sd">            bin_step: float</span>
<span class="sd">                overlap interval for each bin</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Clayton Copula&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span> <span class="o">=</span> <span class="n">buoy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span> <span class="o">=</span> <span class="n">n_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span> <span class="o">=</span> <span class="n">bin_1_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span> <span class="o">=</span> <span class="n">bin_step</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.Hs_SampleCA = None</span>
<span class="c1">#        self.Hs_SampleFSS = None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.T_SampleCA = None</span>
<span class="c1">#        self.T_SampleFSS = None</span>

<span class="c1">#        self.Weight_points = None</span>

<span class="c1">#        self.coeff, self.shift, self.comp1_params, self.sigma_param, self.mu_param = self.__generateParams(size_bin)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EA__getCopulaParams</span><span class="p">(</span><span class="n">n_size</span><span class="p">,</span><span class="n">bin_1_limit</span><span class="p">,</span><span class="n">bin_step</span><span class="p">)</span>

<div class="viewcode-block" id="ClaytonCopula.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.ClaytonCopula.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ss</span><span class="p">,</span> <span class="n">time_r</span><span class="p">,</span> <span class="n">nb_steps</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State Clayton Copula Contour function.</span>
<span class="sd">        This function calculates environmental contours of extreme sea states using</span>
<span class="sd">        a Clayton copula and the inverse first-order reliability</span>
<span class="sd">        method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_ss : float</span>
<span class="sd">            Sea state duration (hours) of measurements in input.</span>
<span class="sd">        time_r : np.array</span>
<span class="sd">            Desired return period (years) for calculation of environmental</span>
<span class="sd">            contour, can be a scalar or a vector.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space used for</span>
<span class="sd">            inverse FORM calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Return : np.array</span>
<span class="sd">            Calculated Hs values along the contour boundary following</span>
<span class="sd">            return to original input orientation.</span>
<span class="sd">        T_Return : np.array</span>
<span class="sd">           Calculated T values along the contour boundary following</span>
<span class="sd">           return to original input orientation.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To obtain the contours for a NDBC buoy::</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            </span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            </span>
<span class="sd">            # Create Environtmal Analysis object using above parameters</span>
<span class="sd">            Clayton46022 = ESSC.ClaytonCopula(buoy46022)</span>
<span class="sd">            </span>
<span class="sd">            # Declare required parameters</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = 100  # Return periods (yrs) of interest</span>
<span class="sd">            nb_steps = 1000  # Enter discretization of the circle in the normal space (optional)</span>
<span class="sd">            </span>
<span class="sd">            # Clayton copula contour generation example</span>
<span class="sd">            Hs_Return, T_Return = Clayton46022.getContours(Time_SS, Time_r,nb_steps)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span> <span class="o">=</span> <span class="n">time_ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span> <span class="o">=</span> <span class="n">time_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span> <span class="o">=</span> <span class="n">nb_steps</span>

        <span class="n">p_f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_r</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_f</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reliability</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nb_steps</span><span class="p">)</span>
        <span class="c1"># Vary U1, U2 along circle sqrt(U1^2+U2^2)=beta</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">comp_1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">exponweib</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">),</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Calculate Kendall&#39;s tau</span>
        <span class="n">theta_clay</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">tau</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">tau</span><span class="p">)</span>

        <span class="n">z2_Clay</span><span class="o">=</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">theta_clay</span><span class="p">)</span><span class="o">+</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">theta_clay</span><span class="p">)</span><span class="o">/</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U2</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="n">theta_clay</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">theta_clay</span><span class="p">)))</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">theta_clay</span><span class="p">)</span>
        <span class="n">comp_2_Clayton</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">z2_Clay</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1">#lognormalinverse</span>

        <span class="n">Hs_Return</span> <span class="o">=</span> <span class="n">comp_1</span>
        <span class="n">T_Return</span> <span class="o">=</span> <span class="n">comp_2_Clayton</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="n">Hs_Return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="n">T_Return</span>
        <span class="k">return</span> <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span></div>

<div class="viewcode-block" id="ClaytonCopula.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.ClaytonCopula.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Currently not implemented in this version&#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_saveParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupObj</span><span class="p">):</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;n_size&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_1_limit&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_step&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_1&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;mean_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;std_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span><span class="p">)</span></div>


<div class="viewcode-block" id="GumbelCopula"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.GumbelCopula">[docs]</a><span class="k">class</span> <span class="nc">GumbelCopula</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Create a GumbelCopula EA class for a buoy object. Contours generated </span>
<span class="sd">    under this class will use a Gumbel copula.&#39;&#39;&#39;</span>    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">n_size</span><span class="o">=</span><span class="mf">40.</span><span class="p">,</span> <span class="n">bin_1_limit</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">bin_step</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span><span class="n">Ndata</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            buoy : NDBCData</span>
<span class="sd">                ESSC.Buoy Object</span>
<span class="sd">            n_size: float</span>
<span class="sd">                minimum bin size used for Copula contour methods</span>
<span class="sd">            bin_1_limit: float</span>
<span class="sd">                maximum value of Hs for the first bin</span>
<span class="sd">            bin_step: float</span>
<span class="sd">                overlap interval for each bin</span>
<span class="sd">            Ndata: int</span>
<span class="sd">                discretization used in the Gumbel copula density estimation, </span>
<span class="sd">                must be less than the number of contour points used in </span>
<span class="sd">                getContours</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Gumbel Copula&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span> <span class="o">=</span> <span class="n">buoy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span> <span class="o">=</span> <span class="n">n_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span> <span class="o">=</span> <span class="n">bin_1_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span> <span class="o">=</span> <span class="n">bin_step</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.Hs_SampleCA = None</span>
<span class="c1">#        self.Hs_SampleFSS = None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.T_SampleCA = None</span>
<span class="c1">#        self.T_SampleFSS = None</span>
<span class="c1">#        self.Weight_points = None</span>

<span class="c1">#        self.coeff, self.shift, self.comp1_params, self.sigma_param, self.mu_param = self.__generateParams(size_bin)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span> <span class="o">=</span> <span class="n">Ndata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_limit_2</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_limit_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EA__getCopulaParams</span><span class="p">(</span><span class="n">n_size</span><span class="p">,</span><span class="n">bin_1_limit</span><span class="p">,</span><span class="n">bin_step</span><span class="p">)</span>

<div class="viewcode-block" id="GumbelCopula.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.GumbelCopula.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ss</span><span class="p">,</span> <span class="n">time_r</span><span class="p">,</span> <span class="n">nb_steps</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State Gumbel Copula Contour function</span>
<span class="sd">        This function calculates environmental contours of extreme sea states using</span>
<span class="sd">        a Gumbel copula and the inverse first-order reliability</span>
<span class="sd">        method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">        time_ss : float</span>
<span class="sd">            Sea state duration (hours) of measurements in input.</span>
<span class="sd">        time_r : np.array</span>
<span class="sd">            Desired return period (years) for calculation of environmental</span>
<span class="sd">            contour, can be a scalar or a vector.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space used for</span>
<span class="sd">            inverse FORM calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Return : np.array</span>
<span class="sd">            Calculated Hs values along the contour boundary following</span>
<span class="sd">            return to original input orientation.</span>
<span class="sd">        T_Return : np.array</span>
<span class="sd">           Calculated T values along the contour boundary following</span>
<span class="sd">           return to original input orientation.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To obtain the contours for a NDBC buoy::</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            </span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            </span>
<span class="sd">            # Create Environtmal Analysis object using above parameters</span>
<span class="sd">            Gumbel46022 = ESSC.GumbelCopula(buoy46022)</span>
<span class="sd">            </span>
<span class="sd">            # Declare required parameters</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = 100  # Return periods (yrs) of interest</span>
<span class="sd">            nb_steps = 1000  # Enter discretization of the circle in the normal space (optional)</span>
<span class="sd">            </span>
<span class="sd">            # Gumbel copula contour generation example</span>
<span class="sd">            Hs_Return, T_Return = Gumbel46022.getContours(Time_SS,Time_r,nb_steps)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span> <span class="o">=</span> <span class="n">time_ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span> <span class="o">=</span> <span class="n">time_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span> <span class="o">=</span> <span class="n">nb_steps</span>

        <span class="n">p_f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_r</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_f</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reliability</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nb_steps</span><span class="p">)</span>
        <span class="c1"># Vary U1, U2 along circle sqrt(U1^2+U2^2)=beta</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">comp_1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">exponweib</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">),</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Calculate Kendall&#39;s tau</span>
        <span class="n">theta_gum</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">tau</span><span class="p">)</span>

        <span class="n">fi_u1</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">);</span>
        <span class="n">fi_u2</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U2</span><span class="p">);</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_limit_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">max_limit_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">)</span>
        <span class="n">z2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">comp_2_Gumb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)):</span>
            <span class="n">z1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">fi_u1</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">fi_u1</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">z1</span><span class="p">,</span><span class="n">z2</span><span class="p">))</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EA__gumbelCopula</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">theta_gum</span><span class="p">)</span> <span class="c1"># Copula density function</span>
            <span class="n">Y</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
            <span class="n">p_x2_x1</span> <span class="o">=</span> <span class="n">Y</span><span class="o">*</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="c1"># pdf 2|1, f(comp_2|comp_1)=c(z1,z2)*f(comp_2)</span>
            <span class="n">dum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">p_x2_x1</span><span class="p">)</span>
            <span class="n">cdf</span> <span class="o">=</span> <span class="n">dum</span><span class="o">/</span><span class="p">(</span><span class="n">dum</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># Estimate CDF from PDF</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x2</span><span class="p">,</span> <span class="n">cdf</span><span class="p">))</span> <span class="c1"># Result of conditional CDF derived based on Gumbel copula</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">T</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">fi_u2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">comp_2_Gumb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">table</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">fi_u2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">comp_2_Gumb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">comp_2_Gumb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="n">Hs_Return</span> <span class="o">=</span> <span class="n">comp_1</span>
        <span class="n">T_Return</span> <span class="o">=</span> <span class="n">comp_2_Gumb</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="n">Hs_Return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="n">T_Return</span>
        <span class="k">return</span> <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span></div>

<div class="viewcode-block" id="GumbelCopula.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.GumbelCopula.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Currently not implemented in this version.&#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_saveParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupObj</span><span class="p">):</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Ndata&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;min_limit_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_limit_2</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;max_limit_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_limit_2</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;n_size&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_1_limit&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_step&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_1&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;mean_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;std_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span><span class="p">)</span></div>

<div class="viewcode-block" id="NonParaGaussianCopula"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.NonParaGaussianCopula">[docs]</a><span class="k">class</span> <span class="nc">NonParaGaussianCopula</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Create a NonParaGaussianCopula EA class for a buoy object. Contours</span>
<span class="sd">    generated under this class will use a Gaussian copula with non-parametric</span>
<span class="sd">    marginal distribution fits.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">Ndata</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">max_T</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_Hs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            buoy : NDBCData</span>
<span class="sd">                ESSC.Buoy Object</span>
<span class="sd">            NData: int</span>
<span class="sd">                discretization resolution used in KDE construction</span>
<span class="sd">            max_T:float</span>
<span class="sd">                Maximum T value for KDE contstruction, must include possible </span>
<span class="sd">                range of contour. Default value is 2*max(T)</span>
<span class="sd">            max_Hs:float</span>
<span class="sd">                Maximum Hs value for KDE contstruction, must include possible </span>
<span class="sd">                range of contour. Default value is 2*max(Hs)    </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Non-parametric Gaussian Copula&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span> <span class="o">=</span> <span class="n">buoy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span> <span class="o">=</span> <span class="n">Ndata</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.Hs_SampleCA = None</span>
<span class="c1">#        self.Hs_SampleFSS = None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.T_SampleCA = None</span>
<span class="c1">#        self.T_SampleFSS = None</span>

<span class="c1">#        self.Weight_points = None</span>

<span class="c1">#        self.coeff, self.shift, self.comp1_params, self.sigma_param, self.mu_param = self.__generateParams(size_bin)</span>
        <span class="k">if</span> <span class="n">max_T</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_T</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="mf">2.</span>
        <span class="k">if</span> <span class="n">max_Hs</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_Hs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span><span class="o">*</span><span class="mf">2.</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">max_T</span> <span class="o">=</span> <span class="n">max_T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_Hs</span> <span class="o">=</span> <span class="n">max_Hs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_pdf_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EA__getNonParaCopulaParams</span><span class="p">(</span><span class="n">Ndata</span><span class="p">,</span><span class="n">max_T</span><span class="p">,</span><span class="n">max_Hs</span><span class="p">)</span>

<div class="viewcode-block" id="NonParaGaussianCopula.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.NonParaGaussianCopula.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ss</span><span class="p">,</span> <span class="n">time_r</span><span class="p">,</span> <span class="n">nb_steps</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State Gaussian Copula Contour function.</span>
<span class="sd">        This function calculates environmental contours of extreme sea states </span>
<span class="sd">        using a Gaussian copula with non-parametric marginal distribution fits</span>
<span class="sd">        and the inverse first-order reliability method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">        time_ss : float</span>
<span class="sd">            Sea state duration (hours) of measurements in input.</span>
<span class="sd">        time_r : np.array</span>
<span class="sd">            Desired return period (years) for calculation of environmental</span>
<span class="sd">            contour, can be a scalar or a vector.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space used for</span>
<span class="sd">            inverse FORM calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Return : np.array</span>
<span class="sd">            Calculated Hs values along the contour boundary following</span>
<span class="sd">            return to original input orientation.</span>
<span class="sd">        T_Return : np.array</span>
<span class="sd">           Calculated T values along the contour boundary following</span>
<span class="sd">           return to original input orientation.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To obtain the contours for a NDBC buoy::</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            </span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            </span>
<span class="sd">            # Create Environtmal Analysis object using above parameters</span>
<span class="sd">            NonParaGauss46022 = ESSC.NonParaGaussianCopula(buoy46022)</span>
<span class="sd">            </span>
<span class="sd">            # Declare required parameters</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = 100  # Return periods (yrs) of interest</span>
<span class="sd">            nb_steps = 1000  # Enter discretization of the circle in the normal space (optional)</span>
<span class="sd">            </span>
<span class="sd">            # Non-Parametric Gaussian copula contour generation example</span>
<span class="sd">            Hs_Return, T_Return = NonParaGauss46022.getContours(Time_SS, Time_r,nb_steps)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span> <span class="o">=</span> <span class="n">time_ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span> <span class="o">=</span> <span class="n">time_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span> <span class="o">=</span> <span class="n">nb_steps</span>
        
        <span class="n">comp_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span>
        <span class="n">comp_2_Gau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span>
        
        <span class="c1"># Inverse FORM</span>
        <span class="n">p_f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_r</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_f</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reliability</span>
        
        <span class="c1"># Normal Space</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nb_steps</span><span class="p">)</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        
        <span class="c1"># Copula parameters</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="c1"># Calculate Kendall&#39;s tau    </span>
        <span class="n">rho_gau</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">tau</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">);</span>
        
        <span class="c1"># Component 1 (Hs)</span>
        <span class="n">z1_Hs</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nb_steps</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">z1_Hs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span> 
                    <span class="n">comp_1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> 
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">z1_Hs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span> 
                    <span class="n">comp_1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">comp_1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># Component 2 (T)</span>
        
        <span class="n">z2_Gau</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">rho_gau</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span><span class="o">+</span><span class="n">rho_gau</span><span class="o">*</span><span class="n">U1</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nb_steps</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">z2_Gau</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span> 
                    <span class="n">comp_2_Gau</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> 
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">z2_Gau</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span> 
                    <span class="n">comp_2_Gau</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">comp_2_Gau</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">Hs_Return</span> <span class="o">=</span> <span class="n">comp_1</span>
        <span class="n">T_Return</span> <span class="o">=</span> <span class="n">comp_2_Gau</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="n">Hs_Return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="n">T_Return</span>
        <span class="k">return</span> <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span></div>

<div class="viewcode-block" id="NonParaGaussianCopula.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.NonParaGaussianCopula.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Currently not implemented in this version.&#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_saveParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupObj</span><span class="p">):</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;nonpara_dist_1&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;nonpara_dist_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="NonParaClaytonCopula"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.NonParaClaytonCopula">[docs]</a><span class="k">class</span> <span class="nc">NonParaClaytonCopula</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Create a NonParaClaytonCopula EA class for a buoy object. Contours</span>
<span class="sd">    generated under this class will use a Clayton copula with non-parametric</span>
<span class="sd">    marginal distribution fits.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">Ndata</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">max_T</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_Hs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            buoy : NDBCData</span>
<span class="sd">                ESSC.Buoy Object</span>
<span class="sd">            NData: int</span>
<span class="sd">                discretization resolution used in KDE construction</span>
<span class="sd">            max_T:float</span>
<span class="sd">                Maximum T value for KDE contstruction, must include possible </span>
<span class="sd">                range of contour. Default value is 2*max(T)</span>
<span class="sd">            max_Hs:float</span>
<span class="sd">                Maximum Hs value for KDE contstruction, must include possible </span>
<span class="sd">                range of contour. Default value is 2*max(Hs)    </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Non-parametric Clayton Copula&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span> <span class="o">=</span> <span class="n">buoy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span> <span class="o">=</span> <span class="n">Ndata</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.Hs_SampleCA = None</span>
<span class="c1">#        self.Hs_SampleFSS = None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.T_SampleCA = None</span>
<span class="c1">#        self.T_SampleFSS = None</span>

<span class="c1">#        self.Weight_points = None</span>

<span class="c1">#        self.coeff, self.shift, self.comp1_params, self.sigma_param, self.mu_param = self.__generateParams(size_bin)</span>
        <span class="k">if</span> <span class="n">max_T</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_T</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="mf">2.</span>
        <span class="k">if</span> <span class="n">max_Hs</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_Hs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span><span class="o">*</span><span class="mf">2.</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">max_T</span> <span class="o">=</span> <span class="n">max_T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_Hs</span> <span class="o">=</span> <span class="n">max_Hs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_pdf_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EA__getNonParaCopulaParams</span><span class="p">(</span><span class="n">Ndata</span><span class="p">,</span><span class="n">max_T</span><span class="p">,</span><span class="n">max_Hs</span><span class="p">)</span>

<div class="viewcode-block" id="NonParaClaytonCopula.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.NonParaClaytonCopula.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ss</span><span class="p">,</span> <span class="n">time_r</span><span class="p">,</span> <span class="n">nb_steps</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State non-parameteric Clayton Copula Contour</span>
<span class="sd">        function. This function calculates environmental contours of extreme</span>
<span class="sd">        sea states using a Clayton copula with non-parametric marginal</span>
<span class="sd">        distribution fits and the inverse first-order reliability method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">        time_ss : float</span>
<span class="sd">            Sea state duration (hours) of measurements in input.</span>
<span class="sd">        time_r : np.array</span>
<span class="sd">            Desired return period (years) for calculation of environmental</span>
<span class="sd">            contour, can be a scalar or a vector.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space used for</span>
<span class="sd">            inverse FORM calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Return : np.array</span>
<span class="sd">            Calculated Hs values along the contour boundary following</span>
<span class="sd">            return to original input orientation.</span>
<span class="sd">        T_Return : np.array</span>
<span class="sd">           Calculated T values along the contour boundary following</span>
<span class="sd">           return to original input orientation.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To obtain the contours for a NDBC buoy::</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            </span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            </span>
<span class="sd">            # Create Environtmal Analysis object using above parameters</span>
<span class="sd">            NonParaClayton46022 = ESSC.NonParaClaytonCopula(buoy46022)</span>
<span class="sd">            </span>
<span class="sd">            # Declare required parameters</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = 100  # Return periods (yrs) of interest</span>
<span class="sd">            nb_steps = 1000  # Enter discretization of the circle in the normal space (optional)</span>
<span class="sd">            </span>
<span class="sd">            # Non-Parametric Clayton copula contour generation example</span>
<span class="sd">            Hs_Return, T_Return = NonParaClayton46022.getContours(Time_SS, Time_r,nb_steps)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span> <span class="o">=</span> <span class="n">time_ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span> <span class="o">=</span> <span class="n">time_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span> <span class="o">=</span> <span class="n">nb_steps</span>
        
        <span class="n">comp_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span>
        <span class="n">comp_2_Clay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span>
        
        <span class="c1"># Inverse FORM</span>
        <span class="n">p_f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_r</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_f</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reliability</span>
        
        <span class="c1"># Normal Space</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nb_steps</span><span class="p">)</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        
        <span class="c1"># Copula parameters</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="c1"># Calculate Kendall&#39;s tau    </span>
        <span class="n">theta_clay</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">tau</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">tau</span><span class="p">);</span>
        
        <span class="c1"># Component 1 (Hs)</span>
        <span class="n">z1_Hs</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nb_steps</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">z1_Hs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span> 
                    <span class="n">comp_1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> 
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">z1_Hs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span> 
                    <span class="n">comp_1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">comp_1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># Component 2 (T)</span>
        
        <span class="n">z2_Clay</span><span class="o">=</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">theta_clay</span><span class="p">)</span><span class="o">+</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">theta_clay</span><span class="p">)</span><span class="o">/</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U2</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="n">theta_clay</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">theta_clay</span><span class="p">)))</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">theta_clay</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nb_steps</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">z2_Clay</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span> 
                    <span class="n">comp_2_Clay</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> 
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">z2_Clay</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span> 
                    <span class="n">comp_2_Clay</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">comp_2_Clay</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">Hs_Return</span> <span class="o">=</span> <span class="n">comp_1</span>
        <span class="n">T_Return</span> <span class="o">=</span> <span class="n">comp_2_Clay</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="n">Hs_Return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="n">T_Return</span>
        <span class="k">return</span> <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span></div>

<div class="viewcode-block" id="NonParaClaytonCopula.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.NonParaClaytonCopula.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Currently not implemented in this version.&#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_saveParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupObj</span><span class="p">):</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;nonpara_dist_1&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;nonpara_dist_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">)</span></div>

<div class="viewcode-block" id="NonParaGumbelCopula"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.NonParaGumbelCopula">[docs]</a><span class="k">class</span> <span class="nc">NonParaGumbelCopula</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Create a NonParaGumbelCopula EA class for a buoy object. Contours</span>
<span class="sd">    generated under this class will use a Gumbel copula with non-parametric</span>
<span class="sd">    marginal distribution fits.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">Ndata</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">max_T</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_Hs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            buoy : NDBCData</span>
<span class="sd">                ESSC.Buoy Object</span>
<span class="sd">            NData: int</span>
<span class="sd">                discretization resolution used in KDE construction</span>
<span class="sd">            max_T:float</span>
<span class="sd">                Maximum T value for KDE contstruction, must include possible </span>
<span class="sd">                range of contour. Default value is 2*max(T)</span>
<span class="sd">            max_Hs:float</span>
<span class="sd">                Maximum Hs value for KDE contstruction, must include possible </span>
<span class="sd">                range of contour. Default value is 2*max(Hs)    </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Non-parametric Gumbel Copula&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span> <span class="o">=</span> <span class="n">buoy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span> <span class="o">=</span> <span class="n">Ndata</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.Hs_SampleCA = None</span>
<span class="c1">#        self.Hs_SampleFSS = None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.T_SampleCA = None</span>
<span class="c1">#        self.T_SampleFSS = None</span>

<span class="c1">#        self.Weight_points = None</span>

<span class="c1">#        self.coeff, self.shift, self.comp1_params, self.sigma_param, self.mu_param = self.__generateParams(size_bin)</span>
        <span class="k">if</span> <span class="n">max_T</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_T</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="mf">2.</span>
        <span class="k">if</span> <span class="n">max_Hs</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_Hs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span><span class="o">*</span><span class="mf">2.</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">max_T</span> <span class="o">=</span> <span class="n">max_T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_Hs</span> <span class="o">=</span> <span class="n">max_Hs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_pdf_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EA__getNonParaCopulaParams</span><span class="p">(</span><span class="n">Ndata</span><span class="p">,</span><span class="n">max_T</span><span class="p">,</span><span class="n">max_Hs</span><span class="p">)</span>

<div class="viewcode-block" id="NonParaGumbelCopula.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.NonParaGumbelCopula.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ss</span><span class="p">,</span> <span class="n">time_r</span><span class="p">,</span> <span class="n">nb_steps</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State non-parameteric Gumbel Copula Contour</span>
<span class="sd">        function. This function calculates environmental contours of extreme</span>
<span class="sd">        sea states using a Gumbel copula with non-parametric marginal</span>
<span class="sd">        distribution fits and the inverse first-order reliability method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">        time_ss : float</span>
<span class="sd">            Sea state duration (hours) of measurements in input.</span>
<span class="sd">        time_r : np.array</span>
<span class="sd">            Desired return period (years) for calculation of environmental</span>
<span class="sd">            contour, can be a scalar or a vector.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space used for</span>
<span class="sd">            inverse FORM calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Return : np.array</span>
<span class="sd">            Calculated Hs values along the contour boundary following</span>
<span class="sd">            return to original input orientation.</span>
<span class="sd">        T_Return : np.array</span>
<span class="sd">           Calculated T values along the contour boundary following</span>
<span class="sd">           return to original input orientation.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To obtain the contours for a NDBC buoy::</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            </span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            </span>
<span class="sd">            # Create Environtmal Analysis object using above parameters</span>
<span class="sd">            NonParaGumbel46022 = ESSC.NonParaGumbelCopula(buoy46022)</span>
<span class="sd">            </span>
<span class="sd">            # Declare required parameters</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = 100  # Return periods (yrs) of interest</span>
<span class="sd">            nb_steps = 1000  # Enter discretization of the circle in the normal space (optional)</span>
<span class="sd">            </span>
<span class="sd">            # Non-Parametric Gumbel copula contour generation example</span>
<span class="sd">            Hs_Return, T_Return = NonParaGumbel46022.getContours(Time_SS, Time_r,nb_steps)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span> <span class="o">=</span> <span class="n">time_ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span> <span class="o">=</span> <span class="n">time_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span> <span class="o">=</span> <span class="n">nb_steps</span>
        
        <span class="n">comp_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span>
        <span class="n">comp_2_Gumb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span>
        
        <span class="c1"># Inverse FORM</span>
        <span class="n">p_f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_r</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_f</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reliability</span>
        
        <span class="c1"># Normal Space</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nb_steps</span><span class="p">)</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        
        <span class="c1"># Copula parameters</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="c1"># Calculate Kendall&#39;s tau    </span>
        <span class="n">theta_gum</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">tau</span><span class="p">);</span>
        
        <span class="c1"># Component 1 (Hs)</span>
        <span class="n">z1_Hs</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nb_steps</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">z1_Hs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span> 
                    <span class="n">comp_1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> 
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">z1_Hs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span> 
                    <span class="n">comp_1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">comp_1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># Component 2 (T)</span>
        
        <span class="n">fi_u1</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">);</span>
        <span class="n">fi_u2</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U2</span><span class="p">);</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nb_steps</span><span class="p">):</span>
            <span class="n">z1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">fi_u1</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">fi_u1</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">z1</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EA__gumbelCopula</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">theta_gum</span><span class="p">)</span>
            <span class="n">Y</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="c1"># Need to look into this</span>
            <span class="n">p_x2_x1</span> <span class="o">=</span> <span class="n">Y</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_pdf_2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">p_x2_x1</span><span class="p">)</span>
            <span class="n">cdf</span> <span class="o">=</span> <span class="n">dum</span><span class="o">/</span><span class="p">(</span><span class="n">dum</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_pdf_2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">cdf</span><span class="p">))</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">T</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">fi_u2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">comp_2_Gumb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">table</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">fi_u2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">comp_2_Gumb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span> 
                    <span class="n">comp_2_Gumb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">table</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>


        <span class="n">Hs_Return</span> <span class="o">=</span> <span class="n">comp_1</span>
        <span class="n">T_Return</span> <span class="o">=</span> <span class="n">comp_2_Gumb</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="n">Hs_Return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="n">T_Return</span>
        <span class="k">return</span> <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span></div>

<div class="viewcode-block" id="NonParaGumbelCopula.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.NonParaGumbelCopula.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Currently not implemented in this version.&#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_saveParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupObj</span><span class="p">):</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;nonpara_dist_1&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_1</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;nonpara_dist_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nonpara_dist_2</span><span class="p">)</span></div>

<div class="viewcode-block" id="BivariateKDE"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.BivariateKDE">[docs]</a><span class="k">class</span> <span class="nc">BivariateKDE</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Create a BivariateKDE EA class for a buoy object. Contours</span>
<span class="sd">    generated under this class will use a non-parametric KDE to fit the joint distribution.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">bw</span><span class="p">,</span> <span class="n">NData</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">logTransform</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_T</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_Hs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            buoy : NDBCData</span>
<span class="sd">                ESSC.Buoy Object</span>
<span class="sd">            bw: np.array</span>
<span class="sd">                Array containing KDE bandwidth for Hs and T</span>
<span class="sd">            NData: int</span>
<span class="sd">                Discretization resolution used in KDE construction</span>
<span class="sd">            logTransform: Boolean</span>
<span class="sd">                Logical. True if log transformation should be taken prior to </span>
<span class="sd">                KDE construction. Default value is False. </span>
<span class="sd">            max_T:float</span>
<span class="sd">                Maximum T value for KDE contstruction, must include possible </span>
<span class="sd">                range of contour. Default value is 2*max(T)</span>
<span class="sd">            max_Hs:float</span>
<span class="sd">                Maximum Hs value for KDE contstruction, must include possible </span>
<span class="sd">                range of contour. Default value is 2*max(Hs)    </span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="k">if</span> <span class="n">logTransform</span><span class="p">:</span>        
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Bivariate KDE, Log Transform&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Bivariate KDE&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span> <span class="o">=</span> <span class="n">buoy</span>
        
        <span class="k">if</span> <span class="n">max_T</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_T</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="mf">2.</span>
        <span class="k">if</span> <span class="n">max_Hs</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_Hs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span><span class="o">*</span><span class="mf">2.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_T</span> <span class="o">=</span> <span class="n">max_T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_Hs</span> <span class="o">=</span> <span class="n">max_Hs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NData</span> <span class="o">=</span> <span class="n">NData</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bw</span> <span class="o">=</span> <span class="n">bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logTransform</span> <span class="o">=</span> <span class="n">logTransform</span>

<div class="viewcode-block" id="BivariateKDE.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.BivariateKDE.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ss</span><span class="p">,</span> <span class="n">time_r</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State non-parameteric bivariate KDE Contour</span>
<span class="sd">        function. This function calculates environmental contours of extreme</span>
<span class="sd">        sea states using a bivariate KDE to estimate the joint distribution. </span>
<span class="sd">        The contour is then calculcated directly from the joint distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">        time_ss : float</span>
<span class="sd">            Sea state duration (hours) of measurements in input.</span>
<span class="sd">        time_r : np.array</span>
<span class="sd">            Desired return period (years) for calculation of environmental</span>
<span class="sd">            contour, can be a scalar or a vector.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Return : np.array</span>
<span class="sd">            Calculated Hs values along the contour boundary following</span>
<span class="sd">            return to original input orientation.</span>
<span class="sd">        T_Return : np.array</span>
<span class="sd">           Calculated T values along the contour boundary following</span>
<span class="sd">           return to original input orientation.</span>


<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To obtain the contours for a NDBC buoy::</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            </span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            </span>
<span class="sd">            # Create Environmental Analysis object using above parameters</span>
<span class="sd">            BivariateKDE46022 = ESSC.BivariateKDE(buoy46022, bw = [0.23,0.19], logTransform = False)</span>
<span class="sd">            </span>
<span class="sd">            # Declare required parameters</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = 100  # Return periods (yrs) of interest</span>
<span class="sd">            </span>
<span class="sd">            # KDE contour generation example</span>
<span class="sd">            Hs_Return, T_Return = BivariateKDE46022.getContours(Time_SS, Time_r)</span>
<span class="sd">        &#39;&#39;&#39;</span>       
        <span class="n">p_f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_r</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logTransform</span><span class="p">:</span> 
            <span class="c1"># Take log of both variables</span>
            <span class="n">logTp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">logHs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span>
            <span class="n">ty</span> <span class="o">=</span> <span class="p">[</span><span class="n">logTp</span><span class="p">,</span> <span class="n">logHs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">ty</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">]</span>
      

        <span class="c1"># Create grid of points</span>
        <span class="n">Ndata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NData</span>
        <span class="n">min_limit_1</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="n">max_limit_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_T</span>
        <span class="n">min_limit_2</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="n">max_limit_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_Hs</span>
        <span class="n">pts_tp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_limit_1</span><span class="p">,</span> <span class="n">max_limit_1</span><span class="p">,</span> <span class="n">Ndata</span><span class="p">)</span> 
        <span class="n">pts_hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_limit_2</span><span class="p">,</span> <span class="n">max_limit_2</span><span class="p">,</span> <span class="n">Ndata</span><span class="p">)</span>
        <span class="n">pt1</span><span class="p">,</span><span class="n">pt2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">pts_tp</span><span class="p">,</span> <span class="n">pts_hs</span><span class="p">)</span>
        <span class="n">pts_tp</span> <span class="o">=</span> <span class="n">pt1</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">pts_hs</span> <span class="o">=</span> <span class="n">pt2</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># Transform gridded points using log</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="p">[</span><span class="n">pts_tp</span><span class="p">,</span> <span class="n">pts_hs</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logTransform</span><span class="p">:</span> 
            <span class="n">txi</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pts_tp</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pts_hs</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">txi</span> <span class="o">=</span> <span class="n">xi</span>

        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">txi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ty</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># Create contour</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="p">))</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
            <span class="n">ftemp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
                <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">txi</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ty</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">bw</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">fk</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logTransform</span><span class="p">:</span>     
                    <span class="n">fnew</span> <span class="o">=</span> <span class="n">fk</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span> 
                    <span class="n">fnew</span> <span class="o">=</span> <span class="n">fk</span>
                <span class="n">fnew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fnew</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">ftemp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">ftemp</span><span class="p">,</span><span class="n">fnew</span><span class="p">)</span>
            <span class="n">f</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span><span class="n">ftemp</span><span class="p">)</span>


        <span class="n">fhat</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span><span class="n">pt2</span><span class="p">,</span><span class="n">fhat</span><span class="p">,</span> <span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">p_f</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">allsegs</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
<span class="c1">#        </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1">#        self.vals = vals    </span>
<span class="c1">#        contourVals = np.empty((0,2))</span>
<span class="c1">#        for seg in vals.allsegs[0]:</span>
<span class="c1">#            contourVals = np.append(contourVals,seg, axis = 0)</span>
<span class="c1">#        self.Hs_ReturnContours = contourVals[:,1]</span>
<span class="c1">#        self.T_ReturnContours = contourVals[:,0]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span></div></div>

        
<div class="viewcode-block" id="Buoy"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Buoy">[docs]</a><span class="k">class</span> <span class="nc">Buoy</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This class creates a buoy object to store buoy data for use in the </span>
<span class="sd">    environmental assessment functions available in the ESSC module.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    __________</span>
<span class="sd">    swdList : list</span>
<span class="sd">        List that contains numpy arrays of the spectral wave density data,</span>
<span class="sd">        separated by year.</span>
<span class="sd">    freqList: list</span>
<span class="sd">        List that contains numpy arrays that contain the frequency values</span>
<span class="sd">        for each year</span>
<span class="sd">    dateList : list</span>
<span class="sd">        List that contains numpy arrays of the date values for each line of</span>
<span class="sd">        spectral data, separated by year</span>
<span class="sd">    Hs : list</span>
<span class="sd">        Significant wave height.</span>
<span class="sd">    T : list</span>
<span class="sd">        Energy period.</span>
<span class="sd">    dateNum : list</span>
<span class="sd">        List of datetime objects.</span>
<span class="sd">    &#39;&#39;&#39;</span>



    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoyNum</span><span class="p">,</span> <span class="n">buoyType</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">            buoyNum : string</span>
<span class="sd">                device number for desired buoy</span>
<span class="sd">            buoyType : string</span>
<span class="sd">                type of buoy device, available options are &#39;NDBC&#39; or &#39;CDIP&#39;</span>
<span class="sd">            savePath : string</span>
<span class="sd">                relative path where the data read from ndbc.noaa.gov will be stored</span>


<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">swdList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freqList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dateNum</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span> <span class="o">=</span> <span class="n">buoyNum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoyType</span> <span class="o">=</span> <span class="n">buoyType</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>



<div class="viewcode-block" id="Buoy.fetchFromWeb"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Buoy.fetchFromWeb">[docs]</a>    <span class="k">def</span> <span class="nf">fetchFromWeb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">savePath</span> <span class="o">=</span> <span class="s2">&quot;./Data/&quot;</span><span class="p">,</span><span class="n">proxy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calls either __fetchCDIP() or __fetchNDBC() depending on the given</span>
<span class="sd">        buoy&#39;s type and fetches the necessary data from its respective website.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        saveType: string</span>
<span class="sd">            If set to to &quot;h5&quot;, the data will be saved in a compressed .h5</span>
<span class="sd">            file</span>
<span class="sd">            If set to &quot;txt&quot;, the data will be stored in a raw .txt file</span>
<span class="sd">            Otherwise, a file will not be created</span>
<span class="sd">            NOTE: Only applies </span>
<span class="sd">        savePath : string</span>
<span class="sd">            Relative path to place directory with data files.</span>
<span class="sd">        proxy: dict</span>
<span class="sd">            Proxy server and port, i.e., {http&quot;:&quot;http://proxyserver:port&quot;}</span>
<span class="sd">        Example</span>
<span class="sd">        _________</span>
<span class="sd">        &gt;&gt;&gt; import WDRT.ESSC as ESSC</span>
<span class="sd">        &gt;&gt;&gt; buoy = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">        &gt;&gt;&gt; buoy.fetchFromWeb()</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoyType</span> <span class="o">==</span> <span class="s2">&quot;NDBC&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__fetchNDBC</span><span class="p">(</span><span class="n">proxy</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoyType</span> <span class="o">==</span> <span class="s2">&quot;CDIP&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__fetchCDIP</span><span class="p">(</span><span class="n">savePath</span><span class="p">,</span><span class="n">proxy</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__fetchNDBC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proxy</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Searches ndbc.noaa.gov for the historical spectral wave density</span>
<span class="sd">        data of a given device and writes the annual files from the website</span>
<span class="sd">        to a single .txt file, and stores the values in the swdList, freqList,</span>
<span class="sd">        and dateList member variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        saveType: string</span>
<span class="sd">            If set to to &quot;h5&quot;, the data will be saved in a compressed .h5</span>
<span class="sd">            file</span>
<span class="sd">            If set to &quot;txt&quot;, the data will be stored in a raw .txt file</span>
<span class="sd">            Otherwise, a file will not be created</span>
<span class="sd">            NOTE: Only applies </span>
<span class="sd">        savePath : string</span>
<span class="sd">            Relative path to place directory with data files.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">maxRecordedDateValues</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="c1">#preallocates data</span>
        <span class="n">numLines</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">numCols</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">numDates</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dateVals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spectralVals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#prepares to pull the data from the NDBC website</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;https://www.ndbc.noaa.gov/station_history.php?station=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">proxy</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ndbcURL</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ndbcURL</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span><span class="n">proxies</span><span class="o">=</span><span class="n">proxy</span><span class="p">)</span>
        <span class="n">ndbcURL</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>
        <span class="n">ndbcHTML</span> <span class="o">=</span> <span class="n">bs4</span><span class="o">.</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">ndbcURL</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="s2">&quot;lxml&quot;</span><span class="p">)</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="n">ndbcHTML</span><span class="o">.</span><span class="n">findAll</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">&quot;Spectral wave density data: &quot;</span><span class="p">)</span>
        <span class="c1">#checks for headers in differently formatted webpages</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Spectral wave density data for buoy #</span><span class="si">%s</span><span class="s2"> not found&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">)</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">headers</span> <span class="o">=</span> <span class="n">headers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">headers</span> <span class="o">=</span> <span class="n">headers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">links</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="s2">&quot;href&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">headers</span><span class="o">.</span><span class="n">find_next_siblings</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">href</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
        <span class="c1">#downloads files</span>
        <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
            <span class="n">dataLink</span> <span class="o">=</span> <span class="s2">&quot;https://ndbc.noaa.gov&quot;</span> <span class="o">+</span> <span class="n">link</span>

            <span class="n">fileName</span> <span class="o">=</span> <span class="n">dataLink</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;download_data&#39;</span><span class="p">,</span> <span class="s1">&#39;view_text_file&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reading from:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">geturl</span><span class="p">())</span>

            <span class="c1">#First Line of every file contains the frequency data</span>
            <span class="n">frequency</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">frequency</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;mm&#39;</span><span class="p">:</span>
                <span class="n">numDates</span> <span class="o">=</span> <span class="mi">5</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">numDates</span> <span class="o">=</span> <span class="mi">4</span>

            <span class="n">frequency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frequency</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="n">numDates</span><span class="p">:],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

            <span class="c1">#splits and organizes data into arrays.</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">currentLine</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">numCols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">currentLine</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">numCols</span> <span class="o">-</span> <span class="n">numDates</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frequency</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NDBC File is corrupted - Skipping and deleting data&quot;</span><span class="p">)</span>
                    <span class="n">spectralVals</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">dateVals</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">break</span>

                <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">currentLine</span><span class="p">[</span><span class="n">numDates</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">999</span><span class="p">:</span>
                    <span class="n">numLines</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxRecordedDateValues</span><span class="p">):</span>
                        <span class="n">dateVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentLine</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCols</span> <span class="o">-</span> <span class="n">numDates</span><span class="p">):</span>
                        <span class="n">spectralVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentLine</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">numDates</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectralVals</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dateValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dateVals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
                <span class="n">spectralValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spectralVals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

                <span class="n">dateValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dateValues</span><span class="p">,</span> <span class="p">(</span><span class="n">numLines</span><span class="p">,</span> <span class="n">maxRecordedDateValues</span><span class="p">))</span>
                <span class="n">spectralValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">spectralValues</span><span class="p">,</span> <span class="p">(</span><span class="n">numLines</span><span class="p">,</span>
                                                             <span class="p">(</span><span class="n">numCols</span> <span class="o">-</span> <span class="n">numDates</span><span class="p">)))</span>
            <span class="n">numLines</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">numCols</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectralVals</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">dateVals</span><span class="p">[:]</span>
                <span class="k">del</span> <span class="n">spectralVals</span><span class="p">[:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">swdList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spectralValues</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">freqList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dateValues</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepData</span><span class="p">()</span>


<div class="viewcode-block" id="Buoy.loadFromTxt"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Buoy.loadFromTxt">[docs]</a>    <span class="k">def</span> <span class="nf">loadFromTxt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirPath</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Loads NDBC data previously downloaded to a series of text files in the</span>
<span class="sd">        specified directory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            dirPath : string</span>
<span class="sd">                Relative path to directory containing NDBC text files (created by</span>
<span class="sd">                NBDCdata.fetchFromWeb). If left blank, the method will search</span>
<span class="sd">                all directories for the data using the current directory as</span>
<span class="sd">                the root.</span>


<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To load data from previously downloaded files </span>
<span class="sd">        created using fetchFromWeb():</span>

<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.loadFromText()</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#preallocates arrays</span>
        <span class="n">dateVals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spectralVals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">numLines</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">maxRecordedDateValues</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="c1">#finds the text files (if they exist on the machine)</span>
        <span class="k">if</span> <span class="n">dirPath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">subdirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">dirs</span> <span class="ow">in</span> <span class="n">subdirs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;NDBC</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
                        <span class="n">dirPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span><span class="n">dirs</span><span class="p">)</span>
                        <span class="k">break</span>
        <span class="k">if</span> <span class="n">dirPath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Could not find directory containing NDBC data&quot;</span><span class="p">)</span>

        <span class="n">fileList</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirPath</span><span class="p">,</span><span class="s1">&#39;SWD*.txt&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fileList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;No NDBC data files found in &quot;</span> <span class="o">+</span> <span class="n">dirPath</span><span class="p">)</span>
        <span class="c1">#reads in the files</span>
        <span class="k">for</span> <span class="n">fileName</span> <span class="ow">in</span> <span class="n">fileList</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reading from: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fileName</span><span class="p">))</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">frequency</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">numCols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">frequency</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;mm&#39;</span><span class="p">:</span>
                <span class="n">frequency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frequency</span><span class="p">[</span><span class="mi">5</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="n">numTimeVals</span> <span class="o">=</span> <span class="mi">5</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">frequency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frequency</span><span class="p">[</span><span class="mi">4</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="n">numTimeVals</span> <span class="o">=</span> <span class="mi">4</span>

            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">currentLine</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">currentLine</span><span class="p">[</span><span class="n">numTimeVals</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">999</span><span class="p">:</span>
                    <span class="n">numLines</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxRecordedDateValues</span><span class="p">):</span>
                        <span class="n">dateVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentLine</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCols</span> <span class="o">-</span> <span class="n">numTimeVals</span><span class="p">):</span>
                        <span class="n">spectralVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentLine</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">numTimeVals</span><span class="p">])</span>

            <span class="n">dateValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dateVals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="n">spectralValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spectralVals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
            <span class="n">dateValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dateValues</span><span class="p">,</span> <span class="p">(</span><span class="n">numLines</span><span class="p">,</span> <span class="n">maxRecordedDateValues</span><span class="p">))</span>
            <span class="n">spectralValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">spectralValues</span><span class="p">,</span> <span class="p">(</span><span class="n">numLines</span><span class="p">,</span> <span class="p">(</span><span class="n">numCols</span> <span class="o">-</span> <span class="n">numTimeVals</span><span class="p">)))</span>

            <span class="k">del</span> <span class="n">dateVals</span><span class="p">[:]</span>
            <span class="k">del</span> <span class="n">spectralVals</span><span class="p">[:]</span>

            <span class="n">numLines</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">numCols</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">swdList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spectralValues</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">freqList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dateValues</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepData</span><span class="p">()</span></div>

<div class="viewcode-block" id="Buoy.loadFile"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Buoy.loadFile">[docs]</a>    <span class="k">def</span> <span class="nf">loadFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirPath</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Loads file depending on whether it&#39;s NDBC or CDIP.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoyType</span> <span class="o">==</span> <span class="s2">&quot;NDBC&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loadFromText</span><span class="p">(</span><span class="n">dirPath</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoyType</span> <span class="o">==</span> <span class="s2">&quot;CDIP&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loadCDIP</span><span class="p">(</span><span class="n">dirPath</span><span class="p">)</span></div>

<div class="viewcode-block" id="Buoy.loadFromH5"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Buoy.loadFromH5">[docs]</a>    <span class="k">def</span> <span class="nf">loadFromH5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads NDBC data previously saved in a .h5 file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            fileName : string</span>
<span class="sd">                Name of the .h5 file to load data from.</span>
<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To load data from previously downloaded files:</span>

<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            buoy46022.saveData()</span>
<span class="sd">            buoy46022.loadFromH5(&#39;NDBC46022.h5&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fileName</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fileName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoyType</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span> <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">file_extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">file_extension</span><span class="p">:</span>
            <span class="n">fileName</span> <span class="o">=</span> <span class="n">fileName</span> <span class="o">+</span> <span class="s1">&#39;.h5&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reading from: &quot;</span><span class="p">,</span> <span class="n">fileName</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Could not find file: &quot;</span> <span class="o">+</span> <span class="n">fileName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;buoy_Data/Hs&#39;</span><span class="p">][:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;buoy_Data/Te&#39;</span><span class="p">][:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dateNum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;buoy_Data/dateNum&#39;</span><span class="p">][:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;buoy_Data/dateList&#39;</span><span class="p">][:])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;----&gt; SUCCESS&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Buoy.saveAsH5"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Buoy.saveAsH5">[docs]</a>    <span class="k">def</span> <span class="nf">saveAsH5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Saves NDBC buoy data to h5 file after fetchFromWeb() or loadFromText(). </span>
<span class="sd">        This data can later be used to create a buoy object using the </span>
<span class="sd">        loadFromH5() function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            fileName : string</span>
<span class="sd">                relevent path and filename where the .h5 file will be created</span>
<span class="sd">                and saved. If no filename, the h5 file will be named </span>
<span class="sd">                NDBC(buoyNum).h5 in location where code is running.</span>
<span class="sd">                </span>
<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To save data to h5 file after fetchFromWeb or loadFromText:</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            buoy46022.saveAsH5()</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fileName</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">fileName</span> <span class="o">=</span> <span class="s1">&#39;NDBC&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.h5&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">file_extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_extension</span><span class="p">:</span>
                <span class="n">fileName</span> <span class="o">=</span> <span class="n">fileName</span> <span class="o">+</span> <span class="s1">&#39;.h5&#39;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_saveData</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saved buoy data&quot;</span><span class="p">);</span></div>
     
<div class="viewcode-block" id="Buoy.saveAsTxt"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Buoy.saveAsTxt">[docs]</a>    <span class="k">def</span> <span class="nf">saveAsTxt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">savePath</span> <span class="o">=</span> <span class="s2">&quot;./Data/&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves spectral wave density data to a .txt file in the same format as the files </span>
<span class="sd">        found on NDBC&#39;s website.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            savePath : string</span>
<span class="sd">                Relative file path where the .txt files will be saved. </span>
<span class="sd">                </span>
<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To save data to h5 file after fetchFromWeb or loadFromText:</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            buoy46022.saveAsTxt()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curYear</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dateIndexDiff</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">bFile</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#NDBC sometimes splits years into two files, the second one titled &quot;YYYYb&quot;</span>
        <span class="n">saveDir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savePath</span><span class="p">,</span> <span class="s1">&#39;NDBC</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saving in :&quot;</span><span class="p">,</span> <span class="n">saveDir</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">saveDir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">saveDir</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">swdList</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">bFile</span><span class="p">:</span>
                <span class="n">swdFile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">saveDir</span><span class="p">,</span> <span class="s2">&quot;SWD-</span><span class="si">%s</span><span class="s2">-</span><span class="si">%d</span><span class="s2">.txt&quot;</span> <span class="o">%</span>
                                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">,</span> <span class="n">curYear</span><span class="p">)),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">swdFile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">saveDir</span><span class="p">,</span> <span class="s2">&quot;SWD-</span><span class="si">%s</span><span class="s2">-</span><span class="si">%d</span><span class="s2">b.txt&quot;</span> <span class="o">%</span>
                                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">,</span> <span class="n">curYear</span><span class="p">)),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                <span class="n">bFile</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="n">freqLine</span> <span class="o">=</span> <span class="s2">&quot;YYYY MM DD hh&quot;</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freqList</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="n">freqLine</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;   &quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">%2.4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
            <span class="n">freqLine</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">swdFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">freqLine</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">dateIndexDiff</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="n">newYear</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">dateIndexDiff</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">curYear</span> <span class="o">!=</span> <span class="n">newYear</span><span class="p">:</span>
                    <span class="n">dateIndexDiff</span> <span class="o">+=</span> <span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">curYear</span> <span class="o">=</span> <span class="n">newYear</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">swdList</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                    <span class="n">dateIndexDiff</span> <span class="o">+=</span> <span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">bFile</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>            
                <span class="n">swdLine</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%0*d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">dateVal</span><span class="p">)</span> <span class="k">for</span> <span class="n">dateVal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">dateIndexDiff</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;   &quot;</span>
                <span class="n">swdLine</span> <span class="o">+=</span> <span class="s2">&quot;   &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">swdList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">swdFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">swdLine</span><span class="p">)</span></div>
                

        


<div class="viewcode-block" id="Buoy.createSubsetBuoy"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Buoy.createSubsetBuoy">[docs]</a>    <span class="k">def</span> <span class="nf">createSubsetBuoy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trainingSize</span><span class="p">):</span>
        
        <span class="sd">&#39;&#39;&#39;Takes a given buoy and creates a subset buoy of a given length in years.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            trainingSize : int</span>
<span class="sd">                The size in years of the subset buoy you would like to create</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            # subsetBuoy : ESSC.Buoy object</span>
<span class="sd">                A buoy (with Hs, T, and dateList values) that is a subset of the given buoy </span>
<span class="sd">        </span>
<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        To get a corresponding subset of a buoy with a given number of years:</span>
<span class="sd">            </span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            </span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy46022 = ESSC.Buoy(&#39;46022&#39;,&#39;NDBC&#39;)</span>
<span class="sd">            buoy46022.fetchFromWeb()</span>
<span class="sd">            </span>
<span class="sd">            # Create a subset of buoy 46022 consisting of the first 10 years</span>
<span class="sd">            subsetBuoy = buoy46022.createSubsetBuoy(10)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>  
        
        <span class="n">subsetBuoy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
        <span class="n">sortedIndex</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dateNum</span><span class="p">)),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dateNum</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dateNum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dateNum</span><span class="p">[</span><span class="n">sortedIndex</span><span class="p">]</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="p">[</span><span class="n">sortedIndex</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">sortedIndex</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">sortedIndex</span><span class="p">]</span>
        
        <span class="n">years</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="p">)):</span>
            <span class="n">years</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            
        <span class="n">trainingYear</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">trainingSize</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">years</span> <span class="o">&lt;=</span> <span class="n">trainingYear</span>  
        
        <span class="n">subsetBuoy</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
        <span class="n">subsetBuoy</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
        <span class="n">subsetBuoy</span><span class="o">.</span><span class="n">dateList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
    
    
        <span class="k">return</span><span class="p">(</span><span class="n">subsetBuoy</span><span class="p">)</span>    </div>

    <span class="k">def</span> <span class="nf">_saveData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileObj</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Organizes and saves wave height, energy period, and date data.&#39;&#39;&#39;</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">gbd</span> <span class="o">=</span> <span class="n">fileObj</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;buoy_Data&#39;</span><span class="p">)</span>
            <span class="n">f_Hs</span> <span class="o">=</span> <span class="n">gbd</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Hs&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span>
            <span class="n">f_Hs</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
            <span class="n">f_Hs</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;significant wave height&#39;</span>
            <span class="n">f_T</span> <span class="o">=</span> <span class="n">gbd</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Te&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">f_T</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
            <span class="n">f_T</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;energy period&#39;</span>
            <span class="n">f_dateNum</span> <span class="o">=</span> <span class="n">gbd</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;dateNum&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dateNum</span><span class="p">)</span>
            <span class="n">f_dateNum</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;datenum&#39;</span>
            <span class="n">f_dateList</span> <span class="o">=</span> <span class="n">gbd</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;dateList&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="p">)</span>
            <span class="n">f_dateList</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;date list&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Buoy object contains no data&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__fetchCDIP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">savePath</span><span class="p">,</span><span class="n">proxy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches the Hs and T values of a CDIP site by downloading the respective .nc file from</span>
<span class="sd">        http://cdip.ucsd.edu/</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        savePath : string</span>
<span class="sd">            Relative path to place directory with data files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;http://thredds.cdip.ucsd.edu/thredds/fileServer/cdip/archive/&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;p1/&quot;</span> <span class="o">+</span> \
               <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">)</span> <span class="o">+</span><span class="s2">&quot;p1_historic.nc&quot;</span>        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Downloading data from: &quot;</span> <span class="o">+</span> <span class="n">url</span><span class="p">)</span>    
        <span class="n">filePath</span> <span class="o">=</span> <span class="n">savePath</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-CDIP.nc&quot;</span>
        <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlretrieve</span> <span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">filePath</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__processCDIPData</span><span class="p">(</span><span class="n">filePath</span><span class="p">)</span>

<div class="viewcode-block" id="Buoy.loadCDIP"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Buoy.loadCDIP">[docs]</a>    <span class="k">def</span> <span class="nf">loadCDIP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filePath</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the Hs and T values of the given site from the .nc file downloaded from </span>
<span class="sd">        http://cdip.ucsd.edu/</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            filePath : string</span>
<span class="sd">                File path to the respective .nc file containing the Hs and T values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filePath</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filePath</span> <span class="o">=</span> <span class="s2">&quot;data/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span> <span class="o">+</span> <span class="s2">&quot;-CDIP.nc&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__processCDIPData</span><span class="p">(</span><span class="n">filePath</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__averageValues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Averages the Hs and T values of the given buoy to get hour time-steps rather than</span>
<span class="sd">        half hour time-steps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__processCDIPData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filePath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the Hs and T values from the .nc file downloaded from http://cdip.ucsd.edu/</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            filePath : string</span>
<span class="sd">                File path to the respective .nc file containing the Hs and T values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">netCDF4</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">filePath</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Could not find data for CDIP site: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;waveHs&quot;</span><span class="p">][:],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;waveTa&quot;</span><span class="p">][:],</span>  <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1">#Some CDIP buoys record data every half hour rather than every hour</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__averageValues</span><span class="p">()</span>



    <span class="k">def</span> <span class="nf">_prepData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Runs _getStats and _getDataNums for full set of data, then removes any</span>
<span class="sd">        NaNs. This cleans and prepares the data for use. Returns wave height, </span>
<span class="sd">        energy period, and dates.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">swdList</span><span class="p">)</span>
        <span class="n">Hs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">T</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dateNum</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span> <span class="o">=</span> <span class="n">_getStats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">swdList</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqList</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
            <span class="n">Hs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span>
            <span class="n">T</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span>
            <span class="n">dateNum</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_getDateNums</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="p">[</span><span class="n">ii</span><span class="p">]))</span>

        <span class="n">dateList</span> <span class="o">=</span> <span class="p">[</span><span class="n">date</span> <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span> <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">year</span><span class="p">]</span>
        <span class="n">Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">dateNum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dateNum</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">dateList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dateList</span><span class="p">)</span>

        <span class="c1"># Removing NaN data, assigning T label depending on input (Te or Tp)</span>
        <span class="n">Nanrem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Hs</span><span class="p">))</span>
        <span class="c1"># Find NaN data in Hs or T</span>
        <span class="n">dateNum</span> <span class="o">=</span> <span class="n">dateNum</span><span class="p">[</span><span class="n">Nanrem</span><span class="p">]</span>  <span class="c1"># Remove any NaN data from DateNum</span>
        <span class="n">Hs</span> <span class="o">=</span> <span class="n">Hs</span><span class="p">[</span><span class="n">Nanrem</span><span class="p">]</span>  <span class="c1"># Remove any NaN data from Hs</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">Nanrem</span><span class="p">]</span>  <span class="c1"># Remove any NaN data from T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="n">Hs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dateNum</span> <span class="o">=</span> <span class="n">dateNum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span> <span class="o">=</span> <span class="n">dateList</span>

        <span class="k">return</span> <span class="n">Hs</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dateNum</span><span class="p">,</span> <span class="n">dateList</span></div>

<span class="k">def</span> <span class="nf">_getDateNums</span><span class="p">(</span><span class="n">dateArr</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;datetime objects</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        dateArr : np.array</span>
<span class="sd">            Array of a specific years date vals from NDBC.fetchFromWeb</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        dateNum : np.array</span>
<span class="sd">            Array of datetime objects.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dateNum</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">times</span> <span class="ow">in</span> <span class="n">dateArr</span><span class="p">:</span>
        <span class="k">if</span>  <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1900</span><span class="p">:</span>
            <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1900</span> <span class="o">+</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dateNum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">toordinal</span><span class="p">(</span><span class="n">datetime</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                               <span class="n">times</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="mi">3</span><span class="p">])))</span>

    <span class="k">return</span> <span class="n">dateNum</span>

<span class="k">def</span> <span class="nf">_getStats</span><span class="p">(</span><span class="n">swdArr</span><span class="p">,</span> <span class="n">freqArr</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Significant wave height and energy period</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            swdArr : np.array</span>
<span class="sd">                Numpy array of the spectral wave density data for a specific year</span>
<span class="sd">            freqArr: np.array</span>
<span class="sd">                Numpy array that contains the frequency values for a specific year</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            Hm0 : list</span>
<span class="sd">                Significant wave height.</span>
<span class="sd">            Te : list</span>
<span class="sd">                Energy period.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#Ignore divide by 0 warnings and resulting NaN warnings</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

        <span class="n">Hm0</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">T</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">swdArr</span><span class="p">:</span>
            <span class="n">m_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">line</span> <span class="o">*</span> <span class="n">freqArr</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">freqArr</span><span class="p">)</span>
            <span class="n">m0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">freqArr</span><span class="p">)</span>
            <span class="n">Hm0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">4.004</span> <span class="o">*</span> <span class="n">m0</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="n">T</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m_1</span> <span class="o">/</span> <span class="n">m0</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Hm0</span><span class="p">,</span> <span class="n">T</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Sandia National Laboratories and The National Renewable Energy Laboratory

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-97337554-1', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>